---
phase: 03-bridge-extraction
plan: 02
type: execute
wave: 2
depends_on: [03-01]
files_modified: [packages/pike-bridge/src/bridge.ts, packages/pike-bridge/src/process.test.ts, packages/pike-bridge/src/index.ts]
autonomous: true

must_haves:
  truths:
    - "PikeBridge uses PikeProcess internally instead of direct child_process"
    - "PikeBridge handles request/response correlation with pending map"
    - "PikeBridge implements timeout policy (30s default)"
    - "PikeBridge wraps Pike errors in PikeError class"
    - "process.test.ts contains unit tests for PikeProcess IPC mechanics"
    - "bridge tests continue to pass with refactored implementation"
    - "index.ts exports PikeProcess for external use if needed"
  artifacts:
    - path: "packages/pike-bridge/src/bridge.ts"
      provides: "Refactored bridge using PikeProcess internally"
      min_lines: 250
      contains: "private process: PikeProcess | null"
    - path: "packages/pike-bridge/src/process.test.ts"
      provides: "Unit tests for PikeProcess IPC mechanics"
      min_lines: 100
    - path: "packages/pike-bridge/src/index.ts"
      provides: "Public exports including PikeProcess"
      contains: "export.*PikeProcess"
  key_links:
    - from: "packages/pike-bridge/src/bridge.ts"
      to: "packages/pike-bridge/src/process.ts"
      via: "import { PikeProcess } from './process.js'"
      pattern: "from '\\./process\\.js'"
    - from: "packages/pike-bridge/src/bridge.ts"
      to: "PikeProcess events"
      via: "this.process.on('message', ...) and other event handlers"
      pattern: "process\\.on\\('message'"
    - from: "packages/pike-bridge/src/process.test.ts"
      to: "PikeProcess"
      via: "Unit tests for spawn, send, kill, isAlive"
      pattern: "describe\\('PikeProcess'"
---

<objective>
Refactor PikeBridge to use PikeProcess internally and add unit tests for both classes.

Purpose: Complete the separation of concerns - PikeProcess handles pure IPC (testable with mocks), PikeBridge handles policy logic (request correlation, timeouts, deduplication, error wrapping). This architecture enables isolated testing and would catch IPC bugs earlier.

Output: Refactored bridge.ts using PikeProcess, new process.test.ts with unit tests, updated index.ts exports.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-bridge-extraction/03-RESEARCH.md
@.planning/phases/03-bridge-extraction/03-01-SUMMARY.md
@.planning/phases/01-lean-observability/01-03-SUMMARY.md
@packages/pike-bridge/src/bridge.ts
@packages/pike-bridge/src/process.ts
@packages/pike-bridge/src/errors.ts
@packages/pike-bridge/src/types.ts
@packages/pike-bridge/src/bridge.test.ts
@packages/pike-bridge/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor PikeBridge to use PikeProcess internally</name>
  <files>packages/pike-bridge/src/bridge.ts</files>
  <action>
    Modify packages/pike-bridge/src/bridge.ts to use PikeProcess:

    1. Add import at top of file:
       ```typescript
       import { PikeProcess } from './process.js';
       ```

    2. Replace the process-related private fields:
       - REMOVE: `private process: ChildProcess | null = null;`
       - REMOVE: `private readline: readline.Interface | null = null;`
       - ADD: `private process: PikeProcess | null = null;`
       - Remove unused imports: `spawn`, `ChildProcess`, `readline` (but keep EventEmitter for PikeBridge's own events)

    3. Update the start() method:
       ```typescript
       async start(): Promise<void> {
           if (this.process) {
               this.debugLog('Process already running, skipping start');
               return;
           }

           this.debugLog(`Starting Pike subprocess: ${this.options.pikePath} ${this.options.analyzerPath}`);
           this.emit('stderr', 'Env: ' + JSON.stringify(this.options.env));

           const pikeProc = new PikeProcess();

           return new Promise((resolve, reject) => {
               // Set up event handlers before spawning
               pikeProc.once('error', (err) => {
                   this.debugLog(`Process error event: ${err.message}`);
                   this.started = false;
                   reject(new Error(`Failed to start Pike subprocess: ${err.message}`));
               });

               // Forward stderr events
               pikeProc.on('stderr', (data) => {
                   const message = data.trim();
                   if (message) {
                       const suppressedPatterns = [
                           /^Illegal comment/,
                           /^Missing ['"]>?['"]\)/,
                       ];
                       const isSuppressed = suppressedPatterns.some(p => p.test(message));

                       if (!isSuppressed) {
                           this.logger.debug('Pike stderr', { raw: message });
                           this.emit('stderr', message);
                       } else {
                           this.logger.trace('Pike stderr (suppressed)', { raw: message });
                       }
                   }
               });

               // Handle message events (JSON-RPC responses)
               pikeProc.on('message', (line) => {
                   this.debugLog(`Received line: ${line.substring(0, 100)}...`);
                   this.handleResponse(line);
               });

               // Handle exit events - reject pending requests
               pikeProc.on('exit', (code) => {
                   this.debugLog(`Process closed with code: ${code}`);
                   this.started = false;
                   this.process = null;
                   this.emit('close', code);

                   // Reject all pending requests
                   for (const [_id, pending] of this.pendingRequests) {
                       clearTimeout(pending.timeout);
                       const error = new PikeError(`Pike process exited with code ${code}`);
                       this.debugLog(`Rejecting pending request: ${error.message}`);
                       pending.reject(error);
                   }
                   this.pendingRequests.clear();
               });

               // Spawn the process
               try {
                   pikeProc.spawn(this.options.analyzerPath, this.options.pikePath, this.options.env);
                   this.debugLog(`Pike subprocess spawned with PID: ${pikeProc.pid}`);
                   this.process = pikeProc;

                   // Give the process a moment to start
                   setTimeout(() => {
                       this.started = true;
                       this.debugLog('Pike subprocess started successfully');
                       this.emit('started');
                       resolve();
                   }, 100);
               } catch (err) {
                   const message = err instanceof Error ? err.message : String(err);
                   this.debugLog(`Exception during start: ${message}`);
                   reject(new Error(`Failed to start Pike bridge: ${message}`));
               }
           });
       }
       ```

    4. Update the stop() method:
       ```typescript
       async stop(): Promise<void> {
           if (this.process) {
               this.debugLog('Stopping Pike subprocess...');
               const proc = this.process;

               // Graceful shutdown via PikeProcess
               proc.kill();

               // Wait a moment for cleanup
               await new Promise(resolve => setTimeout(resolve, 100));

               this.debugLog('Pike subprocess stopped');
               this.process = null;
               this.started = false;
           }
           this.emit('stopped');
       }
       ```

    5. Update sendRequest() to use PikeProcess.send():
       ```typescript
       // Replace this.process?.stdin?.write(json + '\n');
       // With:
       this.process?.send(json);
       ```

    6. Update isRunning():
       ```typescript
       isRunning(): boolean {
           return this.started && this.process !== null && this.process.isAlive();
       }
       ```

    7. Update getDiagnostics():
       ```typescript
       getDiagnostics(): { options: Required<PikeBridgeOptions>; isRunning: boolean; pid: number | null } {
           return {
               options: { ...this.options },
               isRunning: this.isRunning(),
               pid: this.process?.pid ?? null,
           };
       }
       ```

    IMPORTANT: Preserve all existing functionality - request correlation, timeouts, deduplication, error wrapping, and all public API methods (parse, introspect, resolveStdlib, etc.).
  </action>
  <verify>
    - [ ] bridge.ts uses PikeProcess import
    - [ ] `private process: PikeProcess | null` field exists
    - [ ] start() method uses pikeProc.spawn() instead of spawn()
    - [ ] Event handlers use pikeProc.on('message', 'stderr', 'exit', 'error')
    - [ ] sendRequest() uses this.process?.send()
    - [ ] isRunning() uses this.process?.isAlive()
    - [ ] TypeScript compiles: pnpm --filter @pike-lsp/pike-bridge build
    - [ ] All public API methods still exist (parse, introspect, etc.)
  </verify>
  <done>
    PikeBridge refactored to use PikeProcess internally. All IPC mechanics delegated to PikeProcess. Bridge retains policy logic: request correlation, timeouts, deduplication, error wrapping.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create unit tests for PikeProcess</name>
  <files>packages/pike-bridge/src/process.test.ts</files>
  <action>
    Create packages/pike-bridge/src/process.test.ts with unit tests:

    ```typescript
    /**
     * Pike Process Tests
     *
     * Tests the low-level IPC mechanics in isolation from PikeBridge business logic.
     * Uses a mock process pattern to test without requiring actual Pike installation.
     */

    import { describe, it, mock } from 'node:test';
    import assert from 'node:assert/strict';
    import { EventEmitter } from 'events';
    import { PikeProcess } from './process.js';

    /**
     * Mock Pike process for testing without actual Pike subprocess.
     * Simulates the behavior of ChildProcess for isolated unit testing.
     */
    class MockPikeProcess extends EventEmitter {
        public messagesSent: string[] = [];
        public killed = false;
        private _pid = Math.floor(Math.random() * 10000) + 1000;
        private _alive = true;

        constructor() {
            super();
        }

        // Simulate PikeProcess API
        spawn(_analyzerPath: string, _pikePath?: string, _env?: NodeJS.ProcessEnv): void {
            // Simulate successful spawn
            setImmediate(() => {
                this.emit('mock-ready');
            });
        }

        send(json: string): void {
            if (!this._alive) {
                throw new Error('PikeProcess not running');
            }
            this.messagesSent.push(json);
        }

        kill(): void {
            this._alive = false;
            this.killed = true;
            this.emit('exit', 0);
        }

        isAlive(): boolean {
            return this._alive;
        }

        get pid(): number {
            return this._pid;
        }

        // Test helper methods
        simulateMessage(line: string): void {
            this.emit('message', line);
        }

        simulateStderr(data: string): void {
            this.emit('stderr', data);
        }

        simulateError(err: Error): void {
            this.emit('error', err);
        }

        simulateExit(code: number): void {
            this._alive = false;
            this.emit('exit', code);
        }
    }

    describe('PikeProcess', () => {
        describe('Unit tests (with mock)', () => {
            it('should emit message events when receiving stdout lines', (t) => {
                const proc = new MockPikeProcess();
                const messages: string[] = [];

                proc.on('message', (line) => messages.push(line));
                proc.simulateMessage('{"jsonrpc":"2.0","id":1,"result":{}}');
                proc.simulateMessage('{"jsonrpc":"2.0","id":2,"result":{}}');

                assert.equal(messages.length, 2);
                assert.equal(messages[0], '{"jsonrpc":"2.0","id":1,"result":{}}');
                assert.equal(messages[1], '{"jsonrpc":"2.0","id":2,"result":{}}');
            });

            it('should emit stderr events', (t) => {
                const proc = new MockPikeProcess();
                const stderrData: string[] = [];

                proc.on('stderr', (data) => stderrData.push(data));
                proc.simulateStderr('Warning: something happened');
                proc.simulateStderr('Error: something broke');

                assert.equal(stderrData.length, 2);
                assert.equal(stderrData[0], 'Warning: something happened');
                assert.equal(stderrData[1], 'Error: something broke');
            });

            it('should emit exit events with code', (t) => {
                const proc = new MockPikeProcess();
                let exitCode: number | null = null;

                proc.on('exit', (code) => { exitCode = code; });
                proc.simulateExit(0);

                assert.equal(exitCode, 0);
                assert.equal(proc.isAlive(), false);
            });

            it('should emit error events on spawn failure', (t) => {
                const proc = new MockPikeProcess();
                const error: Error[] = [];

                proc.on('error', (err) => error.push(err));
                const err = new Error('Spawn failed');
                proc.simulateError(err);

                assert.equal(error.length, 1);
                assert.equal(error[0].message, 'Spawn failed');
            });

            it('should track sent messages', (t) => {
                const proc = new MockPikeProcess();

                proc.send('{"id":1,"method":"test"}');
                proc.send('{"id":2,"method":"test"}');

                assert.equal(proc.messagesSent.length, 2);
                assert.equal(proc.messagesSent[0], '{"id":1,"method":"test"}');
                assert.equal(proc.messagesSent[1], '{"id":2,"method":"test"}');
            });

            it('should throw when sending to killed process', (t) => {
                const proc = new MockPikeProcess();
                proc.kill();

                assert.throws(
                    () => proc.send('test'),
                    { message: 'PikeProcess not running' }
                );
            });

            it('should report alive status correctly', (t) => {
                const proc = new MockPikeProcess();

                assert.equal(proc.isAlive(), true);
                proc.kill();
                assert.equal(proc.isAlive(), false);
            });

            it('should have a non-zero PID', (t) => {
                const proc = new MockPikeProcess();

                assert.ok(typeof proc.pid === 'number');
                assert.ok(proc.pid > 0);
            });
        });

        describe('Integration tests (requires Pike)', () => {
            let realProc: PikeProcess | null = null;

            it('should spawn real Pike process (if available)', async (t) => {
                // This test requires Pike to be installed
                // It may be skipped in CI environments without Pike
                try {
                    const { spawn } = await import('child_process');
                    const testProc = spawn('pike', ['--version']);

                    await new Promise((resolve, reject) => {
                        testProc.on('close', (code) => {
                            if (code === 0) resolve(undefined);
                            else reject(new Error('Pike not available'));
                        });
                        testProc.on('error', reject);
                        setTimeout(() => reject(new Error('Timeout')), 5000);
                    });
                } catch {
                    // Pike not available, skip this test
                    return;
                }

                // Pike is available, run integration test
                const analyzerPath = '../../pike-scripts/analyzer.pike';
                realProc = new PikeProcess();

                const events: string[] = [];
                realProc.on('message', () => events.push('message'));
                realProc.on('stderr', () => events.push('stderr'));

                realProc.spawn(analyzerPath, 'pike');

                assert.ok(realProc.isAlive());
                assert.ok(realProc.pid !== null);

                // Clean up
                realProc.kill();

                await new Promise(resolve => setTimeout(resolve, 100));
                assert.equal(realProc.isAlive(), false);
            });

            it('should send data to real process (if available)', async (t) => {
                if (!realProc || !realProc.isAlive()) {
                    return; // Skip if real process not available
                }

                // Should not throw
                realProc.send('{"jsonrpc":"2.0","id":999,"method":"parse","params":{"code":"int x;","filename":"test.pike"}}');

                // Clean up
                realProc.kill();
            });
        });
    });
    ```

    NOTE: Integration tests are optional and may be skipped if Pike is not available. The mock-based tests cover the core IPC mechanics.
  </action>
  <verify>
    - [ ] process.test.ts file created
    - [ ] MockPikeProcess class simulates PikeProcess behavior
    - [ ] Unit tests cover: message events, stderr events, exit events, error events
    - [ ] Unit tests cover: send(), isAlive(), pid
    - [ ] Integration tests for real Pike process (with skip if unavailable)
    - [ ] Tests run: pnpm --filter @pike-lsp/pike-bridge test
  </verify>
  <done>
    Unit tests for PikeProcess created using mock pattern. Tests cover IPC mechanics in isolation without requiring Pike installation. Integration tests optional for real subprocess verification.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update index.ts exports and verify existing tests still pass</name>
  <files>packages/pike-bridge/src/index.ts</files>
  <action>
    1. Update packages/pike-bridge/src/index.ts to export PikeProcess:

       Add to the exports:
       ```typescript
       export { PikeProcess } from './process.js';
       ```

       This allows external packages (like pike-lsp-server) to use PikeProcess directly if needed for advanced use cases.

    2. Update package.json test script to include process tests:
       ```json
       "test": "pnpm build && node --test dist/process.test.js dist/bridge.test.js"
       ```

    3. Run the full test suite to verify refactoring didn't break functionality:
       ```bash
       pnpm --filter @pike-lsp/pike-bridge build
       pnpm --filter @pike-lsp/pike-bridge test
       ```

    4. If any tests fail, debug and fix:
       - Check that event handlers are properly connected
       - Verify process cleanup happens correctly
       - Ensure request correlation still works
       - Check that timeout policy is enforced

    TROUBLESHOOTING:
    - If bridge tests fail: Check that PikeProcess events are being handled correctly
    - If process tests fail: Verify mock implementation matches PikeProcess interface
    - If timeout issues: Check that pending requests are cleaned up on process exit
  </action>
  <verify>
    - [ ] index.ts exports PikeProcess
    - [ ] package.json test script includes both process.test.js and bridge.test.js
    - [ ] TypeScript builds successfully
    - [ ] All bridge tests pass (parse, introspect, tokenize, etc.)
    - [ ] All process tests pass (unit and integration if Pike available)
    - [ ] E2E smoke test still works: pnpm --filter @pike-lsp/pike-lsp-server test:smoke
  </verify>
  <done>
    PikeProcess exported from index.ts. All tests pass - bridge tests verify refactored implementation works correctly, process tests verify IPC mechanics in isolation.
  </done>
</task>

</tasks>

<verification>
Overall phase verification:

1. PikeProcess is exported from index.ts
2. PikeBridge uses PikeProcess internally (no direct child_process calls)
3. All existing bridge tests pass (functionality preserved)
4. New process tests pass (IPC mechanics verified)
5. Request correlation still works
6. Timeout policy still enforced
7. Error wrapping still works
8. Request deduplication still works
</verification>

<success_criteria>
1. packages/pike-bridge/src/bridge.ts refactored to use PikeProcess
2. packages/pike-bridge/src/process.test.ts created with unit tests
3. packages/pike-bridge/src/index.ts exports PikeProcess
4. All tests pass (bridge + process)
5. No regression in LSP functionality (smoke tests pass)
</success_criteria>

<output>
After completion, create `.planning/phases/03-bridge-extraction/03-02-SUMMARY.md`
</output>
