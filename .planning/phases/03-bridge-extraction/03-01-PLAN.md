---
phase: 03-bridge-extraction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [packages/pike-bridge/src/process.ts]
autonomous: true

must_haves:
  truths:
    - "PikeProcess class exists in packages/pike-bridge/src/process.ts"
    - "PikeProcess extends EventEmitter and emits message, stderr, exit, error events"
    - "PikeProcess.spawn() starts Pike subprocess with readline for stdout"
    - "PikeProcess.send() writes JSON + newline to stdin"
    - "PikeProcess.kill() closes readline and terminates process"
    - "PikeProcess.isAlive() returns true when process is running"
    - "PikeProcess.pid returns process PID or null"
  artifacts:
    - path: "packages/pike-bridge/src/process.ts"
      provides: "Pure IPC mechanics wrapper for Pike subprocess"
      min_lines: 150
      exports: ["PikeProcess"]
  key_links:
    - from: "packages/pike-bridge/src/process.ts"
      to: "child_process.spawn()"
      via: "Node.js built-in spawn function"
      pattern: "from 'child_process'"
    - from: "packages/pike-bridge/src/process.ts"
      to: "readline.createInterface()"
      via: "Line-by-line stdout reading"
      pattern: "readline\\.createInterface"
    - from: "packages/pike-bridge/src/process.ts"
      to: "EventEmitter"
      via: "Extends EventEmitter for events"
      pattern: "extends EventEmitter"
---

<objective>
Create PikeProcess class to isolate low-level subprocess IPC mechanics from PikeBridge business logic.

Purpose: Extract spawn, readline, and event handling into a reusable, testable component. This separation enables isolated testing of IPC mechanics (critical for catching bugs like the stdin bug) and allows PikeBridge to focus on request/response correlation, timeouts, and deduplication.

Output: New process.ts file with PikeProcess class (~200 lines) extending EventEmitter with spawn(), send(), kill(), isAlive(), and pid getter.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-bridge-extraction/03-RESEARCH.md
@.planning/phases/01-lean-observability/01-03-SUMMARY.md
@packages/pike-bridge/src/bridge.ts
@packages/pike-bridge/src/errors.ts
@packages/pike-bridge/src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PikeProcess class with EventEmitter foundation</name>
  <files>packages/pike-bridge/src/process.ts</files>
  <action>
    Create packages/pike-bridge/src/process.ts with the following structure:

    ```typescript
    /**
     * Pike Process - Low-level subprocess IPC wrapper
     *
     * Manages the Pike interpreter subprocess using JSON-RPC over stdin/stdout.
     * This class handles ONLY IPC mechanics (spawn, readline, events).
     * Business logic (request correlation, timeouts) is handled by PikeBridge.
     */

    import { spawn, ChildProcess } from 'child_process';
    import { EventEmitter } from 'events';
    import * as readline from 'readline';

    /**
     * Events emitted by PikeProcess
     */
    export interface PikeProcessEvents {
        /** A complete JSON-RPC response line received from stdout */
        'message': (line: string) => void;
        /** stderr output from the Pike process */
        'stderr': (data: string) => void;
        /** Process exited with exit code */
        'exit': (code: number | null) => void;
        /** Process failed to start or encountered an error */
        'error': (err: Error) => void;
    }

    /**
     * Low-level wrapper for the Pike subprocess.
     *
     * Handles subprocess lifecycle and line-based JSON-RPC communication.
     * Does NOT handle request correlation, timeouts, or deduplication -
     * those are the responsibility of PikeBridge.
     *
     * @example
     * ```ts
     * const process = new PikeProcess();
     * process.on('message', (line) => console.log('Got:', line));
     * process.spawn('/path/to/analyzer.pike', 'pike');
     * process.send('{"jsonrpc":"2.0","id":1,"method":"parse","params":{...}}');
     * process.kill();
     * ```
     */
    export class PikeProcess extends EventEmitter {
        private process: ChildProcess | null = null;
        private readline: readline.Interface | null = null;
        private _pikePath: string;
        private _analyzerPath: string;

        constructor() {
            super();
            this._pikePath = 'pike';
            this._analyzerPath = '';
        }

        /**
         * Start the Pike subprocess.
         *
         * Spawns the Pike interpreter with the analyzer script and sets up
         * line-based reading of stdout to prevent JSON fragmentation.
         *
         * @param analyzerPath - Path to the analyzer.pike script
         * @param pikePath - Path to Pike executable (default: 'pike')
         * @param env - Environment variables to pass to subprocess
         * @throws Error if spawn fails or pipes cannot be created
         */
        spawn(analyzerPath: string, pikePath: string = 'pike', env: NodeJS.ProcessEnv = {}): void {
            if (this.process) {
                throw new Error('PikeProcess already spawned. Call kill() first.');
            }

            this._analyzerPath = analyzerPath;
            this._pikePath = pikePath;

            this.process = spawn(pikePath, [analyzerPath], {
                stdio: ['pipe', 'pipe', 'pipe'],
                env: { ...process.env, ...env }
            });

            if (!this.process.stdout || !this.process.stdin) {
                this.process = null;
                throw new Error('Failed to create stdin/stdout pipes for Pike subprocess');
            }

            // Line-by-line reading (CRITICAL - prevents JSON fragmentation and stdin bug)
            this.readline = readline.createInterface({
                input: this.process.stdout,
                crlfDelay: Infinity, // Recognize \r\n as single newline
            });

            this.readline.on('line', (line) => {
                this.emit('message', line);
            });

            // Forward stderr to listeners
            this.process.stderr?.on('data', (data: Buffer) => {
                this.emit('stderr', data.toString());
            });

            // Handle process exit
            this.process.on('close', (code) => {
                this.emit('exit', code);
                this.process = null;
                this.readline = null;
            });

            // Handle spawn errors
            this.process.on('error', (err) => {
                this.emit('error', err);
                this.process = null;
                this.readline = null;
            });
        }

        /**
         * Send a JSON-RPC request to the Pike subprocess.
         *
         * Appends newline to ensure complete message delivery.
         *
         * @param json - JSON string to send
         * @throws Error if process is not running or stdin is not writable
         */
        send(json: string): void {
            if (!this.process?.stdin?.writable) {
                throw new Error('PikeProcess not running or stdin not writable');
            }
            this.process.stdin.write(json + '\n');
        }

        /**
         * Terminate the Pike subprocess.
         *
         * Closes the readline interface and sends SIGTERM to the process.
         * Use this for graceful shutdown. For immediate termination, the caller
         * may need to send SIGKILL after a timeout.
         */
        kill(): void {
            this.readline?.close();
            this.process?.kill('SIGTERM');
            this.process = null;
            this.readline = null;
        }

        /**
         * Check if the subprocess is currently running.
         *
         * @returns true if the process exists and has not been killed
         */
        isAlive(): boolean {
            return this.process !== null && !this.process.killed;
        }

        /**
         * Get the process ID of the running subprocess.
         *
         * @returns PID if process is running, null otherwise
         */
        get pid(): number | null {
            return this.process?.pid ?? null;
        }

        /**
         * Get the Pike executable path.
         */
        get pikePath(): string {
            return this._pikePath;
        }

        /**
         * Get the analyzer script path.
         */
        get analyzerPath(): string {
            return this._analyzerPath;
        }
    }
    ```

    IMPORTANT IMPLEMENTATION NOTES:
    - Use readline.createInterface() for line-by-line stdout reading (prevents stdin bug)
    - Emit 'message' event for each complete line from stdout
    - Emit 'stderr' event for stderr data
    - Emit 'exit' event when process closes (include exit code)
    - Emit 'error' event if spawn fails
    - Close readline interface before killing process (prevents memory leaks)
    - Do NOT implement request correlation, timeouts, or deduplication (those are in PikeBridge)
  </action>
  <verify>
    - [ ] process.ts file created with PikeProcess class
    - [ ] Extends EventEmitter
    - [ ] Has spawn(), send(), kill(), isAlive() methods
    - [ ] Has pid, pikePath, analyzerPath getters
    - [ ] Uses readline.createInterface() for stdout
    - [ ] Emits message, stderr, exit, error events
    - [ ] TypeScript compiles without errors: pnpm --filter @pike-lsp/pike-bridge build
  </verify>
  <done>
    PikeProcess class exists with all required methods and events. The class is a pure IPC wrapper with no business logic, ready for isolated testing.
  </done>
</task>

</tasks>

<verification>
Overall verification:

1. TypeScript compiles successfully
2. PikeProcess exports are accessible from the package
3. Event types are properly defined (message, stderr, exit, error)
4. readline interface is used for stdout (not raw data events)
5. Process cleanup happens on exit (readline closed, references nulled)
</verification>

<success_criteria>
1. packages/pike-bridge/src/process.ts exists (~200 lines)
2. PikeProcess class extends EventEmitter
3. spawn(), send(), kill(), isAlive() methods implemented
4. pid, pikePath, analyzerPath getters implemented
5. Emits message, stderr, exit, error events
6. Uses readline for line-based stdout reading
7. TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-bridge-extraction/03-01-SUMMARY.md`
</output>
