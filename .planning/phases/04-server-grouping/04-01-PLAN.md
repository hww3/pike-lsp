---
phase: 04-server-grouping
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/pike-lsp-server/src/core/types.ts
  - packages/pike-lsp-server/src/services/document-cache.ts
  - packages/pike-lsp-server/src/services/bridge-manager.ts
  - packages/pike-lsp-server/src/services/index.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "core/errors.ts and core/logging.ts exist from Phase 1 (SRV-01, SRV-02 already satisfied)"
    - "core/types.ts exports shared types used by features and services"
    - "services/document-cache.ts manages parsed document state"
    - "services/bridge-manager.ts wraps PikeBridge with health monitoring"
    - "services/index.ts bundles all services into Services interface"
    - "Types compile without circular dependency errors"
  artifacts:
    - path: "packages/pike-lsp-server/src/core/errors.ts"
      provides: "Error types and utilities (from Phase 1)"
      exists: true
    - path: "packages/pike-lsp-server/src/core/logging.ts"
      provides: "Logger class (from Phase 1)"
      exists: true
    - path: "packages/pike-lsp-server/src/core/types.ts"
      provides: "Shared types for LSP server"
      exports: ["PikeSettings", "DocumentCacheEntry"]
    - path: "packages/pike-lsp-server/src/services/document-cache.ts"
      provides: "Document cache management"
      exports: ["DocumentCache"]
    - path: "packages/pike-lsp-server/src/services/bridge-manager.ts"
      provides: "Bridge lifecycle and health monitoring"
      exports: ["BridgeManager", "HealthStatus"]
    - path: "packages/pike-lsp-server/src/services/index.ts"
      provides: "Services interface bundle"
      exports: ["Services"]
  key_links:
    - from: "services/index.ts"
      to: "core/types.ts"
      via: "import type"
      pattern: "import.*from.*core/types"
    - from: "services/index.ts"
      to: "services/document-cache.ts"
      via: "import"
      pattern: "import.*from.*document-cache"
    - from: "services/index.ts"
      to: "services/bridge-manager.ts"
      via: "import"
      pattern: "import.*from.*bridge-manager"
    - from: "services/bridge-manager.ts"
      to: "core/logging.ts"
      via: "import Logger"
      pattern: "import.*Logger.*from.*logging"
    - from: "services/index.ts"
      to: "core/logging.ts"
      via: "import Logger"
      pattern: "import.*Logger.*from.*logging"
---

<objective>
Create core infrastructure (types and services) that feature handlers will depend on.

Purpose: Establish the foundation for modular features by extracting shared types and creating service abstractions.
Output: New core/types.ts, services/document-cache.ts, services/bridge-manager.ts, services/index.ts
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Codebase intelligence
@.planning/intel/summary.md

# Source code - existing core files (errors.ts, logging.ts already exist from Phase 1)
@packages/pike-lsp-server/src/core/errors.ts
@packages/pike-lsp-server/src/core/logging.ts
@packages/pike-lsp-server/src/core/index.ts

# Source code - server.ts to extract from
@packages/pike-lsp-server/src/server.ts

# Source code - existing services to reference
@packages/pike-lsp-server/src/type-database.ts
@packages/pike-lsp-server/src/workspace-index.ts
@packages/pike-lsp-server/src/stdlib-index.ts

# Pike bridge types (for BridgeManager)
@packages/pike-bridge/src/index.ts
@packages/pike-bridge/src/types.ts
@packages/pike-bridge/src/bridge.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify core files exist from Phase 1, then create core/types.ts</name>
  <files>packages/pike-lsp-server/src/core/types.ts</files>
  <action>
First, verify that core/errors.ts and core/logging.ts exist from Phase 1 (SRV-01, SRV-02):
```bash
ls packages/pike-lsp-server/src/core/errors.ts packages/pike-lsp-server/src/core/logging.ts
```
These files should already exist - if they don't, the plan should fail.

Then create `packages/pike-lsp-server/src/core/types.ts` with shared types extracted from server.ts:

1. **PikeSettings** interface (lines 107-117 in server.ts):
   - pikePath: string
   - maxNumberOfProblems: number
   - diagnosticDelay: number

2. **DocumentCacheEntry** interface (lines 97-103 in server.ts):
   - version: number
   - symbols: PikeSymbol[]
   - diagnostics: Diagnostic[]
   - symbolPositions: Map&lt;string, Position[]&gt;

3. Import Diagnostic from 'vscode-languageserver/node'
4. Import type { PikeSymbol } from '@pike-lsp/pike-bridge'
5. Import type { Position } from 'vscode-languageserver/node'

DO NOT duplicate - check if these types are used elsewhere first.
  </action>
  <verify>ls packages/pike-lsp-server/src/core/errors.ts packages/pike-lsp-server/src/core/logging.ts && grep -q "export.*PikeSettings" packages/pike-lsp-server/src/core/types.ts && grep -q "export.*DocumentCacheEntry" packages/pike-lsp-server/src/core/types.ts</verify>
  <done>core/errors.ts and core/logging.ts verified from Phase 1; core/types.ts exports PikeSettings and DocumentCacheEntry interfaces</done>
</task>

<task type="auto">
  <name>Task 2: Create services/document-cache.ts</name>
  <files>packages/pike-lsp-server/src/services/document-cache.ts</files>
  <action>
Create `packages/pike-lsp-server/src/services/document-cache.ts`:

Extract DocumentCache class from server.ts (lines 97-104):

```typescript
import type { PikeSymbol } from '@pike-lsp/pike-bridge';
import type { Diagnostic, Position } from 'vscode-languageserver/node';
import type { DocumentCacheEntry } from '../core/types.js';

export class DocumentCache {
  private cache = new Map&lt;string, DocumentCacheEntry&gt;();

  get(uri: string): DocumentCacheEntry | undefined {
    return this.cache.get(uri);
  }

  set(uri: string, entry: DocumentCacheEntry): void {
    this.cache.set(uri, entry);
  }

  delete(uri: string): boolean {
    return this.cache.delete(uri);
  }

  has(uri: string): boolean {
    return this.cache.has(uri);
  }

  clear(): void {
    this.cache.clear();
  }

  entries(): IterableIterator&lt;[string, DocumentCacheEntry]&gt; {
    return this.cache.entries();
  }

  keys(): IterableIterator&lt;string&gt; {
    return this.cache.keys();
  }
}
```

This extracts the inline documentCache Map from server.ts into a proper class.
  </action>
  <verify>grep -q "export class DocumentCache" packages/pike-lsp-server/src/services/document-cache.ts</verify>
  <done>DocumentCache class encapsulates document state management</done>
</task>

<task type="auto">
  <name>Task 3: Create services/bridge-manager.ts</name>
  <files>packages/pike-lsp-server/src/services/bridge-manager.ts</files>
  <action>
Create `packages/pike-lsp-server/src/services/bridge-manager.ts`:

BridgeManager wraps PikeBridge with health monitoring and lifecycle management:

```typescript
import type { PikeBridge } from '@pike-lsp/pike-bridge';
import type { Logger } from '../core/logging.js';

export interface HealthStatus {
  serverUptime: number;
  bridgeConnected: boolean;
  pikePid: number | null;
  pikeVersion: string | null;
  recentErrors: string[];
}

export class BridgeManager {
  private startTime: number;
  private errorLog: string[] = [];
  private readonly MAX_ERRORS = 5;

  constructor(
    private bridge: PikeBridge | null,
    private logger: Logger
  ) {
    this.startTime = Date.now();
    this.setupErrorLogging();
  }

  private setupErrorLogging(): void {
    this.bridge?.on('stderr', (msg: string) => {
      if (msg.toLowerCase().includes('error')) {
        this.errorLog.push(msg);
        if (this.errorLog.length &gt; this.MAX_ERRORS) {
          this.errorLog.shift();
        }
      }
    });
  }

  async getHealth(): Promise&lt;HealthStatus&gt; {
    return {
      serverUptime: Date.now() - this.startTime,
      bridgeConnected: this.bridge?.isRunning() ?? false,
      pikePid: (this.bridge as any)?.process?.pid ?? null,
      pikeVersion: null, // TODO: Implement via introspection
      recentErrors: [...this.errorLog],
    };
  }

  // Delegate to bridge
  async start(): Promise&lt;void&gt; {
    if (this.bridge) await this.bridge.start();
  }

  async stop(): Promise&lt;void&gt; {
    if (this.bridge) await this.bridge.stop();
  }

  isRunning(): boolean {
    return this.bridge?.isRunning() ?? false;
  }

  // Pass-through methods
  async introspect(code: string, filename: string) {
    if (!this.bridge) throw new Error('Bridge not available');
    return this.bridge.introspect(code, filename);
  }

  async parse(code: string, filename: string) {
    if (!this.bridge) throw new Error('Bridge not available');
    return this.bridge.parse(code, filename);
  }

  async findOccurrences(text: string) {
    if (!this.bridge) throw new Error('Bridge not available');
    return this.bridge.findOccurrences(text);
  }

  async getCompletionContext(code: string, offset: number) {
    if (!this.bridge) throw new Error('Bridge not available');
    return this.bridge.getCompletionContext(code, offset);
  }

  async resolveModule(modulePath: string, fromFile: string) {
    if (!this.bridge) throw new Error('Bridge not available');
    return this.bridge.resolveModule(modulePath, fromFile);
  }

  async checkPike(): Promise&lt;boolean&gt; {
    if (!this.bridge) return false;
    return this.bridge.checkPike();
  }

  on(event: string, handler: (...args: any[]) =&gt; void): void {
    this.bridge?.on(event, handler);
  }
}
```

DO NOT implement Pike version detection yet - return null and add TODO comment.
  </action>
  <verify>grep -q "export class BridgeManager" packages/pike-lsp-server/src/services/bridge-manager.ts && grep -q "getHealth" packages/pike-lsp-server/src/services/bridge-manager.ts</verify>
  <done>BridgeManager wraps PikeBridge with health monitoring</done>
</task>

<task type="auto">
  <name>Task 4: Create services/index.ts with Services interface</name>
  <files>packages/pike-lsp-server/src/services/index.ts</files>
  <action>
Create `packages/pike-lsp-server/src/services/index.ts`:

Bundle all services into a single Services interface that feature handlers will receive:

```typescript
import type { Logger } from '../core/logging.js';
import type { DocumentCache } from './document-cache.js';
import type { BridgeManager } from './bridge-manager.js';
import type { TypeDatabase } from '../type-database.js';
import type { WorkspaceIndex } from '../workspace-index.js';
import type { StdlibIndexManager } from '../stdlib-index.js';

export interface Services {
  bridge: BridgeManager;
  logger: Logger;
  documentCache: DocumentCache;
  typeDatabase: TypeDatabase;
  workspaceIndex: WorkspaceIndex;
  stdlibIndex: StdlibIndexManager | null;
}

// Re-export for convenience
export { DocumentCache } from './document-cache.js';
export { BridgeManager, HealthStatus } from './bridge-manager.js';
```

Use `type` imports where possible to avoid circular dependencies.
  </action>
  <verify>grep -q "export interface Services" packages/pike-lsp-server/src/services/index.ts</verify>
  <done>Services interface bundles all service dependencies for feature handlers</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd packages/pike-lsp-server && npx tsc --noEmit`
2. No circular dependency errors in output
3. All exports are properly typed
4. core/errors.ts and core/logging.ts exist (from Phase 1)
</verification>

<success_criteria>
1. core/errors.ts and core/logging.ts verified to exist from Phase 1
2. core/types.ts exports shared types (PikeSettings, DocumentCacheEntry)
3. services/document-cache.ts encapsulates document cache logic
4. services/bridge-manager.ts wraps PikeBridge with health monitoring
5. services/index.ts exports Services interface and re-exports services
6. TypeScript compilation succeeds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-server-grouping/04-01-SUMMARY.md`
</output>
