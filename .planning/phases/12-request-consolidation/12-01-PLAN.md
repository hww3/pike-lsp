---
phase: 12-request-consolidation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [pike-scripts/LSP.pmod/Analysis.pike]
autonomous: true
must_haves:
  truths:
    - "handle_analyze() method exists in Analysis.pike"
    - "Single compilation is shared across parse, introspect, and diagnostics"
    - "Tokenization is performed once and reused"
    - "Results are organized by requested include types"
  artifacts:
    - path: "pike-scripts/LSP.pmod/Analysis.pike"
      provides: "Unified analyze handler"
      contains: "handle_analyze"
  key_links:
    - from: "handle_analyze"
      to: "compile_string"
      via: "single compilation call"
    - from: "handle_analyze"
      to: "Parser.Pike.split/tokenize"
      via: "shared tokenization"
    - from: "handle_analyze"
      to: "introspect_program"
      via: "shared compiled program"
---

<objective>
Implement unified analyze handler in Pike that consolidates compilation, tokenization, and analysis.

Purpose: Reduce redundant work by performing each expensive operation (compilation, tokenization) exactly once per request.
Output: handle_analyze() method that returns multiple result types in a single response.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-request-consolidation/12-CONTEXT.md
@.planning/phases/12-request-consolidation/12-RESEARCH.md
@pike-scripts/LSP.pmod/Analysis.pike
@pike-scripts/LSP.pmod/Parser.pike
@pike-scripts/LSP.pmod/Intelligence.pike
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add handle_analyze method to Analysis.pike</name>
  <files>pike-scripts/LSP.pmod/Analysis.pike</files>
  <action>
    Add a new handle_analyze() method that:
    - Accepts params with: code, filename, include (array of result types to return)
    - Valid include values: "parse", "introspect", "diagnostics", "tokenize"
    - Performs shared operations first:
      1. Tokenization: Parser.Pike.split() + Parser.Pike.tokenize() once
      2. Compilation: compile_string() or master()->resolv() once (if "introspect" requested)
    - Delegates to appropriate handlers based on include array:
      - "parse" -> Parser.pike parse_request() logic (use existing tokens)
      - "introspect" -> Intelligence.pike introspect_program() (use compiled program)
      - "diagnostics" -> Diagnostics.pmod analyze_uninitialized logic (use existing tokens)
      - "tokenize" -> Return the tokenized results
    - Returns response with result/failures structure per CONTEXT.md spec:
      * result: { parse?: ParseResult, introspect?: IntrospectResult, diagnostics?: DiagnosticsResult, tokenize?: TokenizeResult }
      * failures: { parse?: {message, kind}, introspect?: {message, kind}, ... }
    - A requested result type appears in EITHER result OR failures, never both
    - Error kinds are strings: "ParseError", "CompilationError", "ResolutionError", "InternalError"

    IMPORTANT: Each sub-operation should be wrapped in catch() so partial failures don't fail the entire request.
  </action>
  <verify>
    Test with Pike directly:
    echo '{"jsonrpc":"2.0","id":1,"method":"analyze","params":{"code":"int x;","filename":"test.pike","include":["parse","introspect","diagnostics"]}}' | pike pike-scripts/analyzer.pike
    Verify response contains result with all three types, or failures for any that failed.
  </verify>
  <done>handle_analyze() method returns consolidated results with partial success support.</done>
</task>

<task type="auto">
  <name>Task 2: Add performance timing to handle_analyze</name>
  <files>pike-scripts/LSP.pmod/Analysis.pike</files>
  <action>
    Add System.Timer() instrumentation to handle_analyze() to track:
    - compilation_ms: Time spent compiling code
    - tokenization_ms: Time spent tokenizing
    - These are added to the response _perf metadata
    Follow the pattern from dispatch() in analyzer.pike for timing.
  </action>
  <verify>Response includes _perf.compilation_ms and _perf.tokenization_ms when introspect/include requested.</verify>
  <done>Performance metadata tracks breakdown of time spent in each phase.</done>
</task>

</tasks>

<verification>
1. Direct Pike test: Call analyze method with all include types, verify response structure
2. Verify partial success: Intentionally pass invalid code, verify some results succeed while others fail
3. Verify timing: Check _perf metadata in response has compilation_ms/tokenization_ms
</verification>

<success_criteria>
handle_analyze() method consolidates compilation and tokenization, returning all requested result types with partial success support.
</success_criteria>

<output>
After completion, create `.planning/phases/12-request-consolidation/12-01-SUMMARY.md`
</output>
