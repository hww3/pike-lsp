---
phase: 02-parser-module
plan: 03
type: tdd
wave: 3
depends_on: [02-02]
files_modified:
  - test/tests/parser-tests.pike
  - test/fixtures/parser/simple-class.pike
  - test/fixtures/parser/function-with-vars.pike
  - test/fixtures/parser/malformed-syntax.pike
  - test/fixtures/parser/stdlib-sample.pike
autonomous: true

must_haves:
  truths:
    - "Parser unit tests exist for parse_request, tokenize_request, compile_request, batch_parse_request"
    - "Unit tests verify symbol extraction (classes, methods, variables, constants)"
    - "Unit tests verify tokenization (token text, line, file)"
    - "Unit tests verify compilation diagnostics (error capture, warning capture)"
    - "Integration tests verify real Pike code parsing"
    - "Error recovery tests verify parser continues on malformed input"
    - "Tests pass on all target Pike versions (7.6, 7.8, 8.0.x)"
  artifacts:
    - path: test/tests/parser-tests.pike
      provides: Unit and integration tests for Parser class
      min_lines: 300
      contains: "test_parse_simple_class", "test_tokenize", "test_compile_errors", "test_batch_parse"
    - path: test/fixtures/parser/simple-class.pike
      provides: Test fixture for basic class parsing
    - path: test/fixtures/parser/function-with-vars.pike
      provides: Test fixture for local variable extraction
    - path: test/fixtures/parser/malformed-syntax.pike
      provides: Test fixture for error recovery
    - path: test/fixtures/parser/stdlib-sample.pike
      provides: Test fixture for real stdlib code
  key_links:
    - from: parser-tests.pike
      to: Parser.pike
      via: import and instantiation
      pattern: "import LSP; Parser"
    - from: parser-tests.pike
      to: test fixtures
      via: file reading
      pattern: "Stdio.read_file"
---

<objective>
Write comprehensive unit and integration tests for Parser.pike using TDD methodology

Purpose: Verify Parser.pike correctly handles parsing, tokenization, compilation, and batch processing with proper error recovery
Output: parser-tests.pike with unit tests, test fixtures, and passing test suite
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-parser-module/02-CONTEXT.md
@.planning/phases/02-parser-module/02-RESEARCH.md
@.planning/phases/02-parser-module/02-01-SUMMARY.md
@.planning/phases/02-parser-module/02-02-SUMMARY.md
@.planning/phases/01-foundation/01-04-SUMMARY.md
@test/tests/foundation-tests.pike
@pike-scripts/LSP.pmod/Parser.pike
</context>

<feature>
  <name>Parser Test Suite</name>
  <files>
    pike-scripts/LSP.pmod/Parser.pike
    test/tests/parser-tests.pike
    test/fixtures/parser/*.pike
  </files>
  <behavior>
    Parser.pike must:
    1. parse_request: Extract symbols (classes, methods, variables, constants, typedefs, enums)
    2. tokenize_request: Return token stream with text, line, file
    3. compile_request: Capture compilation diagnostics (errors and warnings)
    4. batch_parse_request: Process multiple files, continue on individual failures
    5. Handle malformed input gracefully (error recovery, partial results)
    6. Use LSP.Compat.trim_whites() for cross-version compatibility
  </behavior>
  <implementation>
    Create test file test/tests/parser-tests.pike with:

    Unit tests (fast, focused):
    - test_parse_simple_class: Verify class and method extraction
    - test_parse_variables: Verify variable and constant extraction
    - test_parse_typedef: Verify typedef extraction
    - test_parse_inherit: Verify inherit statement extraction
    - test_tokenize: Verify token stream format
    - test_compile_success: Verify success case returns empty diagnostics
    - test_compile_error: Verify error capture for syntax errors
    - test_compile_warning: Verify warning capture
    - test_batch_parse_single: Verify single file batching
    - test_batch_parse_multiple: Verify multiple file batching
    - test_batch_parse_error_continuation: Verify continues on error
    - test_error_recovery_missing_semicolon: Verify recovery from common errors
    - test_error_recovery_unclosed_brace: Verify recovery from unclosed blocks
    - test_autodoc_extraction: Verify //! comment extraction
    - test_compat_trim_whites: Verify LSP.Compat.trim_whites usage

    Integration tests (real Pike code):
    - test_integration_real_class: Parse actual class from fixture
    - test_integration_stdlib_sample: Parse stdlib sample code
    - test_integration_malformed_file: Test error recovery on real malformed code

    Test fixtures in test/fixtures/parser/:
    - simple-class.pike: Basic class with methods
    - function-with-vars.pike: Function with local variables
    - malformed-syntax.pike: Code with syntax errors
    - stdlib-sample.pike: Sample from Pike stdlib

    Use VSCode console format for output (green/red indicators).
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>Task 1: RED phase - Write failing tests for parse_request</name>
  <files>test/tests/parser-tests.pike</files>
  <action>
Create test/tests/parser-tests.pike with failing tests for parse_request:

1. File header with main() entry point
2. Import LSP module
3. Test counter and failure tracking
4. VSCode console format (ANSI colors)

Tests to write (ALL should fail initially):
```pike
int test_count = 0;
int pass_count = 0;
int fail_count = 0;

void test_parse_simple_class() {
    test_count++;
    Parser p = Parser();
    mapping result = p->parse_request(([
        "code": "class MyApp { void create() { } }",
        "filename": "test.pike",
        "line": 1
    ]));

    array symbols = result->result->symbols;
    // Expect: 1 symbol (class MyApp)
    if (sizeof(symbols) >= 1 && symbols[0]->name == "MyApp" && symbols[0]->kind == "class") {
        pass_count++;
        werror("\033[32m[PASS]\033[0m test_parse_simple_class\n");
    } else {
        fail_count++;
        werror("\033[31m[FAIL]\033[0m test_parse_simple_class: Expected class MyApp, got %O\n", symbols);
    }
}

void test_parse_variables() {
    test_count++;
    Parser p = Parser();
    mapping result = p->parse_request(([
        "code": "int x = 5;\nstring y = \"hello\";\nconstant PI = 3.14;",
        "filename": "test.pike",
        "line": 1
    ]));

    array symbols = result->result->symbols;
    // Expect: 3 symbols (int x, string y, constant PI)
    bool has_x = false, has_y = false, has_pi = false;
    foreach (symbols, mapping sym) {
        if (sym->name == "x" && sym->kind == "variable") has_x = true;
        if (sym->name == "y" && sym->kind == "variable") has_y = true;
        if (sym->name == "PI" && sym->kind == "constant") has_pi = true;
    }
    if (has_x && has_y && has_pi) {
        pass_count++;
        werror("\033[32m[PASS]\033[0m test_parse_variables\n");
    } else {
        fail_count++;
        werror("\033[31m[FAIL]\033[0m test_parse_variables: Missing variables (x:%d y:%d PI:%d)\n", has_x, has_y, has_pi);
    }
}

// Add more tests: test_parse_typedef, test_parse_inherit, test_autodoc_extraction, etc.
```

Run tests and verify they fail (Parser.pike not implemented yet or returning wrong output).
Commit: `test(02-03): add failing Parser tests`
  </action>
  <verify>
    pike test/tests/parser-tests.pike
    Should show red failures for all tests.
  </verify>
  <done>
    parser-tests.pike exists with failing tests
    Tests fail as expected (RED phase)
    Committed to git
  </done>
</task>

<task type="auto">
  <name>Task 2: GREEN phase - Implement Parser.pike to pass tests</name>
  <files>pike-scripts/LSP.pmod/Parser.pike</files>
  <action>
Ensure Parser.pike implementation passes all tests:

1. Verify parse_request correctly extracts all symbol types
2. Verify tokenize_request returns correct token format
3. Verify compile_request captures diagnostics
4. Verify batch_parse_request handles multiple files
5. Verify all helpers work correctly (_get_symbol_kind, _type_to_json, etc.)
6. Verify LSP.Compat.trim_whites() is used throughout

If any tests fail, fix Parser.pike implementation:
- Check symbol extraction logic in parse_request
- Check token format in tokenize_request
- Check error capture in compile_request
- Check batch processing in batch_parse_request
- Verify helper migrations from analyzer.pike are complete

DO NOT change test expectations - fix implementation to match tests.
  </action>
  <verify>
    pike test/tests/parser-tests.pike
    All tests should pass (green).
  </verify>
  <done>
    All Parser tests pass
    Parser.pike correctly implements all required functionality
    Committed to git: `feat(02-03): implement Parser to pass tests`
  </done>
</task>

<task type="auto">
  <name>Task 3: Create test fixtures and integration tests</name>
  <files>
    test/fixtures/parser/simple-class.pike
    test/fixtures/parser/function-with-vars.pike
    test/fixtures/parser/malformed-syntax.pike
    test/fixtures/parser/stdlib-sample.pike
    test/tests/parser-tests.pike
  </files>
  <action>
Create test fixture files:

1. test/fixtures/parser/simple-class.pike:
```pike
//! Simple test class
class TestClass {
    //! A method
    void test_method() {
        int local_var = 5;
    }

    //! Another method
    string get_value() {
        return "test";
    }
}

//! Global constant
constant GLOBAL_CONST = 42;

//! Global variable
string global_var = "hello";
```

2. test/fixtures/parser/function-with-vars.pike:
```pike
//! Function with local variables
void process_data(string input) {
    string trimmed = String.trim_whites(input);
    array parts = trimmed / " ";
    mapping result = ([]);

    foreach (parts, string part) {
        result[part] = sizeof(part);
    }
}
```

3. test/fixtures/parser/malformed-syntax.pike:
```pike
//! File with syntax errors
class BrokenClass {
    void missing_semicolon() {
        int x = 5  // Missing semicolon
        int y = 10;
    }

    void unclosed_brace() {
        int z = 20;
    // Missing closing brace
}
```

4. test/fixtures/parser/stdlib-sample.pike (actual stdlib code):
```pike
//! Sample from Pike stdlib
mapping(string:mixed) get_port_options(int port) {
    mapping(string:mixed) opts = ([
        "port": port,
        "reuse": 1,
    ]);

    return opts;
}
```

Add integration tests to parser-tests.pike:
```pike
void test_integration_real_class() {
    test_count++;
    string code = Stdio.read_file("test/fixtures/parser/simple-class.pike");
    Parser p = Parser();
    mapping result = p->parse_request(([
        "code": code,
        "filename": "simple-class.pike",
        "line": 1
    ]));

    array symbols = result->result->symbols;
    // Verify we found TestClass, test_method, get_value, GLOBAL_CONST, global_var
    // Check for expected symbols
    bool found_class = false, found_method = false, found_const = false;
    foreach (symbols, mapping sym) {
        if (sym->name == "TestClass") found_class = true;
        if (sym->name == "test_method") found_method = true;
        if (sym->name == "GLOBAL_CONST") found_const = true;
    }

    if (found_class && found_method && found_const) {
        pass_count++;
        werror("\033[32m[PASS]\033[0m test_integration_real_class\n");
    } else {
        fail_count++;
        werror("\033[31m[FAIL]\033[0m test_integration_real_class: Missing symbols\n");
    }
}
```
  </action>
  <verify>
    pike test/tests/parser-tests.pike
    All tests including integration tests pass.
  </verify>
  <done>
    Test fixtures created in test/fixtures/parser/
    Integration tests added to parser-tests.pike
    All tests pass
    Committed to git
  </done>
</task>

<task type="auto">
  <name>Task 4: REFACTOR phase - Clean up and optimize</name>
  <files>
    test/tests/parser-tests.pike
    pike-scripts/LSP.pmod/Parser.pike
  </files>
  <action>
Review and clean up:

1. Check for code duplication in tests (extract common setup/teardown)
2. Add test helper functions if useful (e.g., assert_has_symbol())
3. Review Parser.pike for obvious optimizations
4. Add missing AutoDoc comments if any
5. Verify all tests still pass after cleanup

Example test helper:
```pike
protected bool has_symbol(array symbols, string name, string kind) {
    foreach (symbols, mapping sym) {
        if (sym->name == name && sym->kind == kind) return true;
    }
    return false;
}
```

Only refactor if obvious improvements exist. Don't change for the sake of changing.
  </action>
  <verify>
    pike test/tests/parser-tests.pike
    All tests still pass after refactoring.
  </verify>
  <done>
    Code is clean and well-organized
    Test helpers extracted where useful
    AutoDoc comments complete
    All tests pass
    Committed if changes made: `refactor(02-03): clean up Parser tests`
  </done>
</task>

</tasks>

<verification>
1. parser-tests.pike exists with comprehensive test coverage
2. Test fixtures exist in test/fixtures/parser/
3. All unit tests pass (parse, tokenize, compile, batch_parse)
4. All integration tests pass (real code from fixtures)
5. Error recovery tests verify parser handles malformed input
6. Tests use VSCode console format for clear output
7. Tests committed to git with proper messages (RED -> GREEN -> REFACTOR)
</verification>

<success_criteria>
1. At least 15 test functions covering all Parser methods
2. All tests pass with green indicators
3. Test fixtures include: simple class, function with vars, malformed code, stdlib sample
4. Integration tests verify real-world parsing scenarios
5. Error recovery tests verify graceful handling of syntax errors
6. Code coverage: all public methods and major helper paths tested
</success_criteria>

<output>
After completion, create `.planning/phases/02-parser-module/02-03-SUMMARY.md`
</output>
