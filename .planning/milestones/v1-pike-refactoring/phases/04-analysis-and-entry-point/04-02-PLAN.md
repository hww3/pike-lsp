---
phase: 04-analysis-and-entry-point
plan: 02
type: execute
wave: 2
depends_on: [04-01]
files_modified:
  - pike-scripts/LSP.pmod/Analysis.pike
autonomous: true

must_haves:
  truths:
    - "handle_get_completion_context determines completion context at cursor position"
    - "Context types: global, identifier, member_access, scope_access"
    - "Returns operator (->, ., ::), objectName, and prefix"
    - "Uses Parser.Pike tokenization for accurate position detection"
    - "Tokenization errors return empty context (not crash)"
  artifacts:
    - path: "pike-scripts/LSP.pmod/Analysis.pike"
      provides: "Stateless analysis class with handle_get_completion_context method"
      contains: "handle_get_completion_context"
      exports: ["handle_get_completion_context"]
  key_links:
    - from: "handle_get_completion_context"
      to: "Parser.Pike"
      via: "Parser.Pike.split() and Parser.Pike.tokenize() calls"
      pattern: "Parser\\.Pike\\.(split|tokenize)"
    - from: "handle_get_completion_context"
      to: "get_char_position"
      via: "protected helper for position calculation"
      pattern: "get_char_position"
---

<objective>
Add handle_get_completion_context method to Analysis.pike class. This handler analyzes code around a cursor position to determine completion context (global, identifier, member access, scope access) which enables accurate code completion in the LSP client.

Purpose: Extract the completion context handler from analyzer.pike (lines 2301-2424) into the modular Analysis class. This handler uses tokenization to find access operators (->, ., ::) and determine the object being accessed.

Output: Analysis.pike with handle_get_completion_context method that returns context type, operator, objectName, and prefix.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-analysis-and-entry-point/04-CONTEXT.md
@.planning/phases/04-analysis-and-entry-point/04-RESEARCH.md
@.planning/phases/04-analysis-and-entry-point/04-01-SUMMARY.md
@pike-scripts/analyzer.pike
@pike-scripts/LSP.pmod/Analysis.pike
</context>

<tasks>

<task type="auto">
  <name>Add handle_get_completion_context method to Analysis.pike</name>
  <files>pike-scripts/LSP.pmod/Analysis.pike</files>
  <action>
    Add handle_get_completion_context method to Analysis class by extracting from analyzer.pike lines 2305-2424.

    Method signature:
    ```pike
    mapping handle_get_completion_context(mapping params)
    ```

    Implementation details:
    1. Extract params: code (string, default ""), line (int, default 1), character (int, default 0)
    2. Initialize result mapping with defaults:
       - context: "none"
       - objectName: ""
       - prefix: ""
       - operator: ""
    3. Wrap all logic in catch block
    4. Call Parser.Pike.split() then Parser.Pike.tokenize()
    5. Find token at or before cursor position (iterate tokens, track line/char)
    6. Scan backwards from cursor to find access operators (->, ., ::)
    7. If operator found: determine objectName by scanning backwards from operator
    8. Set context based on operator ("scope_access" for ::, "member_access" for -> or .)
    9. If no operator: set context to "identifier"
    10. On error: debug log and return result with default "none" context

    IMPORTANT MIGRATIONS:
    - Replace String.trim_whites() with LSP.Compat.trim_whites()
    - Use get_char_position helper (already in Analysis class from 04-01)
    - On catch: log via debug() and return result (not LSP.LSPError - this handler gracefully degrades)

    Response structure:
    ```pike
    return ([
        "result": result
    ]);
    ```

    Where result contains:
    - context: "none" | "global" | "identifier" | "member_access" | "scope_access"
    - objectName: string (empty if no object)
    - prefix: string (partial identifier being typed)
    - operator: string (empty, "->", ".", or "::")
  </action>
  <verify>pike -e "import LSP.Analysis; Analysis a = Analysis(); mapping r = a->handle_get_completion_context(([\"code\": \"int x = foo->b\", \"line\": 1, \"character\": 10])); write(\"%O\n\", r);"</verify>
  <done>handle_get_completion_context returns context with operator, objectName, and prefix based on cursor position</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Load Analysis.pike and instantiate Analysis class
2. Call handle_get_completion_context with code containing member access (foo->bar)
3. Verify context is "member_access", operator is "->", objectName is "foo"
4. Test with scope access (module::symbol) - verify "scope_access" context
5. Test with plain identifier - verify "identifier" context with no operator
6. Verify tokenization errors don't crash (return "none" context)
</verification>

<success_criteria>
1. handle_get_completion_context method exists in Analysis class
2. Returns correct context type for member access (->, .)
3. Returns correct context type for scope access (::)
4. Returns "identifier" context for plain identifiers
5. objectName is correctly extracted from before the operator
6. Uses LSP.Compat.trim_whites() instead of String.trim_whites()
7. Uses get_char_position helper for position calculation
8. Gracefully handles tokenization errors (returns "none" context)
</success_criteria>

<output>
After completion, create `.planning/phases/04-analysis-and-entry-point/04-02-SUMMARY.md`
</output>
