---
phase: 04-analysis-and-entry-point
plan: 04
type: execute
wave: 3
depends_on: [04-01, 04-02, 04-03]
files_modified:
  - pike-scripts/analyzer.pike
autonomous: true

must_haves:
  truths:
    - "analyzer.pike contains Context class as service container"
    - "Context holds Parser, Intelligence, Analysis instances"
    - "Context holds program_cache, stdlib_cache instances"
    - "Context has debug_mode and client_capabilities fields"
    - "analyzer.pike contains HANDLERS constant dispatch table"
    - "analyzer.pike contains dispatch() function for routing"
    - "main() initializes Context at startup"
  artifacts:
    - path: "pike-scripts/analyzer.pike"
      provides: "JSON-RPC router with Context service container and dispatch table"
      contains: "class Context"
      contains: "constant HANDLERS"
      contains: "protected mapping dispatch"
  key_links:
    - from: "analyzer.pike"
      to: "LSP.Parser"
      via: "Context->parser instance"
      pattern: "parser->parse_request"
    - from: "analyzer.pike"
      to: "LSP.Intelligence"
      via: "Context->intelligence instance"
      pattern: "intelligence->handle_"
    - from: "analyzer.pike"
      to: "LSP.Analysis"
      via: "Context->analysis instance"
      pattern: "analysis->handle_"
    - from: "HANDLERS dispatch table"
      to: "module handlers"
      via: "Context parameter passed through lambda"
      pattern: "lambda.*params.*Context.*ctx"
---

<objective>
Refactor analyzer.pike into a lightweight JSON-RPC router with Context service container and dispatch table. This completes the modularization by establishing the routing layer that delegates to Parser, Intelligence, and Analysis modules.

Purpose: Transform analyzer.pike from a monolithic handler file to a clean router that:
1. Uses a dispatch table for O(1) method lookup
2. Normalizes errors to JSON-RPC format
3. Provides Context as a dependency injection container
4. Initializes module singletons at startup

Output: Refactored analyzer.pike with Context class, HANDLERS dispatch table, dispatch() function, and main() JSON-RPC loop.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-analysis-and-entry-point/04-CONTEXT.md
@.planning/phases/04-analysis-and-entry-point/04-RESEARCH.md
@.planning/phases/04-analysis-and-entry-point/04-01-SUMMARY.md
@.planning/phases/04-analysis-and-entry-point/04-02-SUMMARY.md
@.planning/phases/04-analysis-and-entry-point/04-03-SUMMARY.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/02-parser-module/02-01-SUMMARY.md
@.planning/phases/03-intelligence-module**---extract-introspection-and-resolution-handlers/03-04-SUMMARY.md
@pike-scripts/analyzer.pike
@pike-scripts/LSP.pmod/Cache.pmod
</context>

<tasks>

<task type="auto">
  <name>Add Context class to analyzer.pike</name>
  <files>pike-scripts/analyzer.pike</files>
  <action>
    Add Context class to analyzer.pike (before main() function) following CONTEXT.md Module Instantiation decision.

    Context structure:
    ```pike
    class Context {
        LSP.Cache program_cache;
        LSP.Cache stdlib_cache;
        LSP.Parser parser;
        LSP.Intelligence intelligence;
        LSP.Analysis analysis;
        int debug_mode;
        mapping client_capabilities;

        void create() {
            // Initialize caches first
            program_cache = LSP.Cache();
            stdlib_cache = LSP.Cache();

            // Initialize module instances using master()->resolv pattern
            program ParserClass = master()->resolv("LSP.Parser")->Parser;
            parser = ParserClass();

            program IntelligenceClass = master()->resolv("LSP.Intelligence")->Intelligence;
            intelligence = IntelligenceClass();

            program AnalysisClass = master()->resolv("LSP.Analysis")->Analysis;
            analysis = AnalysisClass();

            debug_mode = 0;
            client_capabilities = ([]);
        }
    }
    ```

    Initialization order matters (per CONTEXT.md):
    1. Caches (no dependencies)
    2. Parser (stateless, no LSP dependencies)
    3. Intelligence (may use Parser)
    4. Analysis (uses Parser, may use Intelligence)

    Place this class after the existing cache-related code but before main(). Keep existing global cache variables for now (cleanup in 04-05).
  </action>
  <verify>pike -e "master()->add_module_path(\"pike-scripts\"); program C = master()->resolv(\"main\")->Context; object ctx = C();"</verify>
  <done>Context class exists and can be instantiated with all module instances</done>
</task>

<task type="auto">
  <name>Add HANDLERS dispatch table constant to analyzer.pike</name>
  <files>pike-scripts/analyzer.pike</files>
  <action>
    Add HANDLERS constant mapping before handle_request() function, following CONTEXT.md Router Design Pattern.

    Dispatch table structure:
    ```pike
    constant HANDLERS = ([
        "parse": lambda(mapping params, Context ctx) {
            return ctx->parser->parse_request(params);
        },
        "tokenize": lambda(mapping params, Context ctx) {
            return ctx->parser->tokenize_request(params);
        },
        "compile": lambda(mapping params, Context ctx) {
            return ctx->parser->compile_request(params);
        },
        "batch_parse": lambda(mapping params, Context ctx) {
            return ctx->parser->batch_parse_request(params);
        },
        "introspect": lambda(mapping params, Context ctx) {
            return ctx->intelligence->handle_introspect(params);
        },
        "resolve": lambda(mapping params, Context ctx) {
            return ctx->intelligence->handle_resolve(params);
        },
        "resolve_stdlib": lambda(mapping params, Context ctx) {
            return ctx->intelligence->handle_resolve_stdlib(params);
        },
        "get_inherited": lambda(mapping params, Context ctx) {
            return ctx->intelligence->handle_get_inherited(params);
        },
        "find_occurrences": lambda(mapping params, Context ctx) {
            return ctx->analysis->handle_find_occurrences(params);
        },
        "analyze_uninitialized": lambda(mapping params, Context ctx) {
            return ctx->analysis->handle_analyze_uninitialized(params);
        },
        "get_completion_context": lambda(mapping params, Context ctx) {
            return ctx->analysis->handle_get_completion_context(params);
        },
        "set_debug": lambda(mapping params, Context ctx) {
            ctx->debug_mode = params->debug || 0;
            return (["result": (["debug_mode": ctx->debug_mode])]);
        },
    ]);
    ```

    Key design points:
    - Each lambda receives (params, Context) for dependency injection
    - Handlers delegate directly to module instances via ctx->module->handler()
    - set_debug is handled inline (modifies Context, no module needed)
    - O(1) lookup via constant mapping

    Place HANDLERS constant before handle_request() but after Context class definition.
  </action>
  <verify>grep -n "constant HANDLERS" pike-scripts/analyzer.pike && grep -c "lambda(mapping params, Context ctx)" pike-scripts/analyzer.pike</verify>
  <done>HANDLERS constant exists with all 12 method handlers, each lambda takes Context parameter</done>
</task>

<task type="auto">
  <name>Add dispatch() function and update handle_request() in analyzer.pike</name>
  <files>pike-scripts/analyzer.pike</files>
  <action>
    Add dispatch() function and refactor handle_request() to use it, following CONTEXT.md Router Design Pattern.

    New dispatch() function:
    ```pike
    protected mapping dispatch(string method, mapping params, Context ctx) {
        // Get handler from dispatch table
        function handler = HANDLERS[method];

        if (!handler) {
            return ([
                "error": ([
                    "code": -32601,
                    "message": "Method not found: " + method
                ])
            ]);
        }

        // Call handler with error normalization - Context passed through
        mixed err = catch {
            return handler(params, ctx);
        };

        return ([
            "error": ([
                "code": -32000,
                "message": describe_error(err)
            ])
        ]);
    }
    ```

    Updated handle_request():
    ```pike
    protected mapping handle_request(mapping request, Context ctx) {
        string method = request->method || "";
        mapping params = request->params || ([]);
        return dispatch(method, params, ctx);
    }
    ```

    Key changes:
    - handle_request now takes Context parameter
    - handle_request delegates to dispatch()
    - dispatch() handles routing and error normalization
    - dispatch() passes Context to handler via handler(params, ctx) call
    - Method not found returns -32601 (standard JSON-RPC)
    - Handler errors return -32000 with describe_error()

    Keep the existing switch statement in handle_request for now - we'll remove it in 04-05 after verifying the new dispatch works.
  </action>
  <verify>grep -n "protected mapping dispatch" pike-scripts/analyzer.pike && grep -n "handler(params, ctx)" pike-scripts/analyzer.pike</verify>
  <done>dispatch() function exists with handler(params, ctx) call pattern, handle_request() takes Context parameter</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Load analyzer.pike in Pike
2. Create Context instance
3. Call dispatch() with "parse" method - verify parser delegation works via ctx->parser->parse_request
4. Call dispatch() with "introspect" method - verify intelligence delegation works via ctx->intelligence->handle_introspect
5. Call dispatch() with "find_occurrences" method - verify analysis delegation works via ctx->analysis->handle_find_occurrences
6. Call dispatch() with unknown method - verify -32601 error response
7. Verify all HANDLERS lambdas have Context parameter (grep for "lambda(mapping params, Context ctx)")
8. Verify dispatch() passes ctx to handler (grep for "handler(params, ctx)")
</verification>

<success_criteria>
1. Context class exists with all module instances
2. HANDLERS constant has 12 method entries
3. Each HANDLERS lambda has (params, Context ctx) signature
4. dispatch() function performs O(1) method lookup
5. dispatch() passes Context to handler via handler(params, ctx)
6. dispatch() returns -32601 for unknown methods
7. dispatch() wraps handler errors in -32000 responses
8. handle_request() delegates to dispatch()
9. All module singletons initialized once in Context.create()
</success_criteria>

<output>
After completion, create `.planning/phases/04-analysis-and-entry-point/04-04-SUMMARY.md`
</output>
