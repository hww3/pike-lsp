---
phase: 01-foundation
plan: 05
type: execute
wave: 3
depends_on: [01-01, 01-02, 01-03, 01-04]
files_modified: [test/tests/e2e-foundation-tests.pike]
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "module.pmod json_decode/encode handles real LSP protocol JSON from stdlib sources"
    - "Compat.trim_whites() produces identical output to native String.trim_whites() on real stdlib strings"
    - "Cache.pmod stores and retrieves real compiled programs from stdlib modules"
    - "E2E tests run successfully against Pike stdlib at /home/smuks/Antigravity/PikeLSP/Pike-v8.0.1116/lib"
    - "Test output uses VSCode console format (timestamp + severity + message)"
  artifacts:
    - path: "test/tests/e2e-foundation-tests.pike"
      provides: "E2E tests for foundation components"
      min_lines: 300
  key_links:
    - from: "e2e-foundation-tests.pike"
      to: "/home/smuks/Antigravity/PikeLSP/Pike-v8.0.1116/lib/modules"
      via: "compile_string() and master()->resolv()"
      pattern: "compile_string|resolv"
---

<objective>
Create end-to-end tests that verify Phase 1 foundation components (module.pmod, Compat.pmod, Cache.pmod) work correctly with real Pike stdlib source code and LSP protocol data.

Purpose: Validate foundation modules handle real-world data, not just synthetic test cases. Catch edge cases that unit tests miss.
Output: E2E test suite that passes against actual Pike stdlib at /home/smuks/Antigravity/PikeLSP/Pike-v8.0.1116/lib
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/01-foundation/01-03-SUMMARY.md
@.planning/phases/01-foundation/01-04-SUMMARY.md

@pike-scripts/LSP.pmod/module.pmod
@pike-scripts/LSP.pmod/Compat.pmod
@pike-scripts/LSP.pmod/Cache.pmod
@test/tests/foundation-tests.pike
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create E2E test infrastructure with VSCode console output format</name>
  <files>test/tests/e2e-foundation-tests.pike</files>
  <action>
Create test/tests/e2e-foundation-tests.pike with:

1. VSCode-style console output format:
   - Format: [timestamp] [LEVEL] message
   - Timestamp: ISO 8601 format (sprintf("%Y-%m-%dT%H:%M:%S"))
   - Levels: TEST, PASS, FAIL, INFO, ERROR
   - Color codes if available (terminal detection)

2. Test runner structure mirroring foundation-tests.pike:
   - setup_module_path() for LSP.pmod resolution
   - run_test() wrapper with error handling
   - get_compat(), get_cache(), get_module() helpers
   - Tests run, passed, failed counters

3. Stdlib path configuration:
   - Constant STDLIB_PATH = "/home/smuks/Antigravity/PikeLSP/Pike-v8.0.1116/lib"
   - Modules path = STDLIB_PATH + "/modules"
   - Verify path exists before running tests

4. Test helpers for E2E scenarios:
   - load_real_module(string module_name): Loads real stdlib module
   - read_module_source(string module_name): Reads .pmod file source
   - create_mock_lsp_request(): Creates realistic LSP JSON-RPC request

Do not add actual test cases yet - infrastructure only.
  </action>
  <verify>
Run: pike test/tests/e2e-foundation-tests.pike
Expected: Test infrastructure initializes, reports 0 tests (no test cases yet)
  </verify>
  <done>
E2E test file exists with VSCode console format, module path setup, and helper functions ready for test cases
  </done>
</task>

<task type="auto">
  <name>Task 2: Test module.pmod with real LSP protocol JSON data</name>
  <files>test/tests/e2e-foundation-tests.pike</files>
  <action>
Add to e2e-foundation-tests.pike - module.pmod E2E tests:

1. test_module_json_decode_real_lsp_initialize():
   - Create realistic LSP initialize request JSON:
     {"jsonrpc":"2.0","id":1,"method":"initialize","params":{"processId":12345,"rootUri":"file:///home/user/project","capabilities":{"textDocument":{"completion":{"completionItem":{"snippetSupport":true}}}}}}
   - Call LSP.json_decode()
   - Verify decoded structure contains expected keys
   - Verify params.rootUri is accessible

2. test_module_json_encode_real_lsp_completion_response():
   - Create Pike mapping matching LSP CompletionItem response:
     (["jsonrpc":"2.0","id":1,"result":(["items":({(["label":"example","kind":1,"detail":"test detail"])})])])
   - Call LSP.json_encode()
   - Verify output is valid JSON string
   - Verify JSON contains "result" and "items" keys

3. test_module_lserror_to_response():
   - Create LSP.LSPError with code=-32600 (Invalid Request)
   - Call to_response()
   - Verify response mapping contains "error" key
   - Verify error.code and error.message are present

4. test_module_debug_output_format():
   - Enable debug mode: LSP.set_debug_mode(1)
   - Call LSP.debug() with test message
   - Capture stderr output (if possible) or verify no crash
   - Disable debug mode: LSP.set_debug_mode(0)

Each test should log using VSCode console format.
  </action>
  <verify>
Run: pike test/tests/e2e-foundation-tests.pike 2>&1 | grep "module_json"
Expected: All module.pmod E2E tests pass
  </verify>
  <done>
module.pmod handles real LSP JSON requests/responses, error structures encode/decode correctly
  </done>
</task>

<task type="auto">
  <name>Task 3: Test Compat.trim_whites() against real stdlib strings</name>
  <files>test/tests/e2e-foundation-tests.pike</files>
  <action>
Add to e2e-foundation-tests.pike - Compat.pmod E2E tests:

1. test_compat_trim_whites_real_stdlib_sources():
   - Read actual .pmod files from stdlib:
     * /home/smuks/Antigravity/PikeLSP/Pike-v8.0.1116/lib/modules/Array.pmod
     * /home/smuks/Antigravity/PikeLSP/Pike-v8.0.1116/lib/modules/String.pmod
     * /home/smuks/Antigravity/PikeLSP/Pike-v8.0.1116/lib/modules/Math.pmod
   - For each file, extract lines with leading whitespace (indented code)
   - Apply Compat.trim_whites() to each line
   - Verify leading whitespace removed
   - Verify trailing whitespace (if present) removed
   - Verify code content preserved

2. test_compat_trim_whites_matches_native_behavior():
   - Create test strings from stdlib source examples:
     * "  constant foo = bar;\n"
     * "\t//! Documentation comment\n"
     * "  mixed result;\n  "
   - Apply both Compat.trim_whites() AND native String.trim_whites() (on Pike 8.x)
   - Compare results - both should produce identical output
   - If on Pike 8.x, verify equivalence; if on 7.x/7.8, verify polyfill works

3. test_compat_version_detection_real_pike():
   - Call LSP.Compat.pike_version()
   - Verify version >= 7.6
   - Verify version matches runtime __REAL_VERSION__
   - Log detected version using INFO level

4. test_compat_trim_whites_unicode_and_edge_cases():
   - Test with real-world edge cases from stdlib:
     * Empty strings
     * Strings with only whitespace
     * Strings with mixed tabs and spaces (common in Pike code)
     * Strings with Unicode (if present in stdlib)
   - Verify no crashes or unexpected behavior
  </action>
  <verify>
Run: pike test/tests/e2e-foundation-tests.pike 2>&1 | grep "compat"
Expected: All Compat.pmod E2E tests pass with real stdlib source strings
  </verify>
  <done>
Compat.trim_whites() correctly processes real Pike source code, matches native behavior where available
  </done>
</task>

<task type="auto">
  <name>Task 4: Test Cache.pmod with real compiled stdlib programs</name>
  <files>test/tests/e2e-foundation-tests.pike</files>
  <action>
Add to e2e-foundation-tests.pike - Cache.pmod E2E tests:

1. test_cache_real_program_compilation_and_caching():
   - Read simple Pike code snippet from stdlib (e.g., a small function)
   - Use compile_string() to create real program object
   - Store in Cache.put_program() with hash key
   - Retrieve with Cache.get_program()
   - Verify retrieved program matches original
   - Verify type is program (use programp())

2. test_cache_stdlib_module_resolution():
   - Load real stdlib module: master()->resolv("Array")
   - Create symbol data mapping from module (functions, constants)
   - Store in Cache.put_stdlib()
   - Retrieve with Cache.get_stdlib()
   - Verify symbol data structure is preserved
   - Test multiple modules (Array, String, Math if available)

3. test_cache_lru_with_real_programs():
   - Compile 3-4 real Pike code snippets
   - Set cache limit to 3
   - Add all to cache
   - Access first item to make it recent
   - Add fourth item (should evict second)
   - Verify LRU eviction worked correctly
   - Verify stats track hits/misses accurately

4. test_cache_statistics_with_real_workload():
   - Clear both caches
   - Simulate realistic usage pattern:
     * Add 5 program entries
     * Mix of hits and misses
     * Add some stdlib entries
   - Verify get_stats() returns accurate counts
   - Verify program_size, stdlib_size are correct
   - Log statistics using INFO level

5. test_cache_clear_and_reuse():
   - Fill program_cache with entries
   - Call clear("program_cache")
   - Verify all entries gone (size = 0)
   - Add new entries (should work after clear)
   - Verify cache is functional after clear
  </action>
  <verify>
Run: pike test/tests/e2e-foundation-tests.pike 2>&1 | grep "cache"
Expected: All Cache.pmod E2E tests pass with real compiled programs
  </verify>
  <done>
Cache.pmod correctly stores/retrieves real compiled programs, LRU eviction works with actual program objects
  </done>
</task>

<task type="auto">
  <name>Task 5: Add main test runner and documentation</name>
  <files>test/tests/e2e-foundation-tests.pike</files>
  <action>
Complete e2e-foundation-tests.pike:

1. Add main() function that:
   - Sets up module path
   - Verifies stdlib path exists
   - Runs all E2E tests in order
   - Prints summary with VSCode console format:
     * Total tests run
     * Tests passed
     * Tests failed
     * List of failures if any
   - Returns exit code 0 for all pass, 1 for any failure

2. Add file header documentation:
   //! E2E Foundation Tests for LSP.pmod
   //!
   //! End-to-end tests verifying foundation components work with real data:
   //! - Real LSP protocol JSON messages
   //! - Real Pike stdlib source code
   //! - Real compiled program objects
   //!
   //! Stdlib path: /home/smuks/Antigravity/PikeLSP/Pike-v8.0.1116/lib
   //!
   //! Run with: pike test/tests/e2e-foundation-tests.pike
   //!
   //! @note Requires Pike stdlib to be present at configured path

3. Add test registration in main():
   - Module tests (json decode/encode, LSPError, debug)
   - Compat tests (real stdlib strings, version detection)
   - Cache tests (real programs, LRU, statistics)

4. Add TODO comment for future enhancement:
   // TODO: Add tests for Logging.pmod when implemented
   // TODO: Add tests for Protocol.pmod when implemented
   // TODO: Cross-version tests on Pike 7.6, 7.8, 8.0.x
  </action>
  <verify>
Run: pike test/tests/e2e-foundation-tests.pike
Expected: All tests pass, VSCode console output shows timestamps and levels
  </verify>
  <done>
Complete E2E test suite runs successfully, provides clear output for debugging in VSCode
  </done>
</task>

</tasks>

<verification>
Overall verification criteria:

1. E2E test file exists at test/tests/e2e-foundation-tests.pike
2. All tests pass when run with Pike interpreter
3. Stdlib path is verified before tests run
4. VSCode console format is used (timestamps, levels)
5. Tests use real data from Pike stdlib
6. Tests cover module.pmod, Compat.pmod, and Cache.pmod

Run: pike test/tests/e2e-foundation-tests.pike

Expected output format:
[2026-01-19T18:30:00] [INFO] Starting E2E Foundation Tests
[2026-01-19T18:30:00] [TEST] module.pmod JSON decode with real LSP request
[2026-01-19T18:30:00] [PASS] module_json_decode_real_lsp_initialize
...
[2026-01-19T18:30:01] [INFO] Results: N run, N passed, 0 failed
</verification>

<success_criteria>
1. E2E test file created and executable
2. All tests pass against real Pike stdlib
3. VSCode console output format implemented
4. Tests verify module.pmod handles LSP JSON correctly
5. Tests verify Compat.trim_whites() works on real stdlib strings
6. Tests verify Cache.pmod stores real compiled programs
7. Test output is clear and debuggable
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-05-SUMMARY.md` with:
- Tests created (count and coverage)
- Real stdlib modules tested
- Any issues found with real data
- Confirmation that all foundation modules handle real-world inputs correctly
</output>
