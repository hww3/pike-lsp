---
phase: 01-foundation
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - LSP.pmod/Cache.pmod
autonomous: true

must_haves:
  truths:
    - "LSP.Cache.get('program_cache', key) retrieves cached values"
    - "LSP.Cache.put('program_cache', key, value) stores values"
    - "LSP.Cache.clear('program_cache') empties the cache"
    - "Exceeding max_cached_programs triggers LRU eviction"
    - "Cache statistics track hits, misses, and current size"
  artifacts:
    - path: "LSP.pmod/Cache.pmod"
      provides: "LRU caching infrastructure for program_cache and stdlib_cache"
      min_lines: 80
      exports: ["get", "put", "clear", "get_stats"]
  key_links:
    - from: "Cache.pmod"
      to: "program_cache mapping"
      via: "internal storage"
      pattern: "mapping(string:program) program_cache"
    - from: "Cache.pmod"
      to: "stdlib_cache mapping"
      via: "internal storage"
      pattern: "mapping(string:mapping) stdlib_cache"
---

<objective>
Create Cache.pmod with get/put/clear interface for program_cache and stdlib_cache, implementing strict LRU eviction policy when size limits are exceeded.

Purpose: Cache.pmod encapsulates all caching state (QLT-04), providing a clean interface for storing compiled programs and stdlib data. The LRU eviction policy ensures memory usage stays bounded while keeping frequently-used items accessible. This replaces the direct mapping access in analyzer.pike with a proper abstraction.

Output: Loadable LSP.pmod/Cache.pmod with get(key), put(key, value), and clear() methods for both program_cache and stdlib_cache, including LRU eviction logic and statistics tracking.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/codebase/CONVENTIONS.md
@pike-scripts/analyzer.pike
</context>

<tasks>

<task type="auto">
  <name>Create Cache.pmod with LRU caching infrastructure</name>
  <files>LSP.pmod/Cache.pmod</files>
  <action>
    Create LSP.pmod/Cache.pmod with the following components:

    1. **Internal storage** (based on analyzer.pike lines 29-34):
       ```pike
       // Program cache: stores compiled programs by source hash
       private mapping(string:program) program_cache = ([]);

       // Stdlib cache: stores module symbol data
       private mapping(string:mapping) stdlib_cache = ([]);

       // Access time tracking for LRU
       private mapping(string:int) cache_access_time = ([]);

       // Maximum cache sizes (configurable)
       private int max_cached_programs = 30;
       private int max_stdlib_modules = 50;

       // Statistics
       private mapping(string:int) stats = ([
           "program_hits": 0,
           "program_misses": 0,
           "stdlib_hits": 0,
           "stdlib_misses": 0
       ]);
       ```

    2. **Program cache operations** (FND-08, FND-10):
       ```pike
       //! Get a compiled program from cache
       program get_program(string key) {
           if (program_cache[key]) {
               stats["program_hits"]++;
               cache_access_time[key] = time();
               return program_cache[key];
           }
           stats["program_misses"]++;
           return 0; // Not found
       }

       //! Put a compiled program in cache with LRU eviction
       void put_program(string key, program prog) {
           // Check if we need to evict
           if (sizeof(program_cache) >= max_cached_programs && !program_cache[key]) {
               evict_lru_program();
           }
           program_cache[key] = prog;
           cache_access_time[key] = time();
       }

       //! Clear all programs from cache
       void clear_programs() {
           program_cache = ([]);
           cache_access_time = ([]);
       }
       ```

    3. **Stdlib cache operations** (FND-09, FND-10):
       ```pike
       //! Get stdlib data from cache
       mapping get_stdlib(string key) {
           if (stdlib_cache[key]) {
               stats["stdlib_hits"]++;
               cache_access_time["stdlib:" + key] = time();
               return stdlib_cache[key];
           }
           stats["stdlib_misses"]++;
           return 0; // Not found
       }

       //! Put stdlib data in cache with LRU eviction
       void put_stdlib(string key, mapping data) {
           // Check if we need to evict
           if (sizeof(stdlib_cache) >= max_stdlib_modules && !stdlib_cache[key]) {
               evict_lru_stdlib();
           }
           stdlib_cache[key] = data;
           cache_access_time["stdlib:" + key] = time();
       }

       //! Clear all stdlib data from cache
       void clear_stdlib() {
           stdlib_cache = ([]);
       }
       ```

    4. **LRU eviction implementation**:
       ```pike
       //! Evict least-recently-used program
       private void evict_lru_program() {
           string lru_key = 0;
           int lru_time = time() + 1;

           foreach (program_cache; string key; program prog) {
               int at = cache_access_time[key] || 0;
               if (at < lru_time) {
                   lru_time = at;
                   lru_key = key;
               }
           }

           if (lru_key) {
               m_delete(program_cache, lru_key);
               m_delete(cache_access_time, lru_key);
           }
       }

       //! Evict least-recently-used stdlib module
       private void evict_lru_stdlib() {
           string lru_key = 0;
           int lru_time = time() + 1;
           string prefix = "stdlib:";

           foreach (stdlib_cache; string key; mapping data) {
               int at = cache_access_time[prefix + key] || 0;
               if (at < lru_time) {
                   lru_time = at;
                   lru_key = key;
               }
           }

           if (lru_key) {
               m_delete(stdlib_cache, lru_key);
               m_delete(cache_access_time, prefix + lru_key);
           }
       }
       ```

    5. **Unified interface** (convenience methods):
       ```pike
       //! Generic get - detects cache type by key prefix or separate call
       mixed get(string cache_name, string key) {
           switch (cache_name) {
               case "program_cache":
                   return get_program(key);
               case "stdlib_cache":
                   return get_stdlib(key);
               default:
                   return 0;
           }
       }

       //! Generic put
       void put(string cache_name, string key, mixed value) {
           switch (cache_name) {
               case "program_cache":
                   put_program(key, value);
                   break;
               case "stdlib_cache":
                   put_stdlib(key, value);
                   break;
           }
       }

       //! Generic clear
       void clear(string cache_name) {
           switch (cache_name) {
               case "program_cache":
                   clear_programs();
                   break;
               case "stdlib_cache":
                   clear_stdlib();
                   break;
               case "all":
                   clear_programs();
                   clear_stdlib();
                   break;
           }
       }
       ```

    6. **Statistics and configuration**:
       ```pike
       //! Get cache statistics
       mapping get_stats() {
           return ([
               "program_hits": stats["program_hits"],
               "program_misses": stats["program_misses"],
               "program_size": sizeof(program_cache),
               "program_max": max_cached_programs,
               "stdlib_hits": stats["stdlib_hits"],
               "stdlib_misses": stats["stdlib_misses"],
               "stdlib_size": sizeof(stdlib_cache),
               "stdlib_max": max_stdlib_modules
           ]);
       }

       //! Set maximum cache sizes
       void set_limits(int max_programs, int max_stdlib) {
           max_cached_programs = max_programs;
           max_stdlib_modules = max_stdlib;
       }
       ```

    Follow CONTEXT.md decisions:
    - Strict LRU: evict exactly one least-recently-used item per insertion
    - Manual invalidation only (no mtime checking)
    - Minimal stats: hit rate, miss rate, current size
    - Graceful degradation: cache failures don't crash the LSP

    Reference analyzer.pike lines 29-34 for the existing cache patterns being refactored.
  </action>
  <verify>pike -e 'LSP.Cache.put("program_cache", "test", 42); write("%d\n", LSP.Cache.get("program_cache", "test"));' 2>&1</verify>
  <done>
    - get() retrieves cached values
    - put() stores values and triggers LRU eviction when limits exceeded
    - clear() empties the specified cache
    - get_stats() returns hit/miss counts and current sizes
    - set_limits() allows runtime configuration of cache sizes
  </done>
</task>

</tasks>

<verification>
After completing all tasks, verify the Cache module works correctly:

```bash
cd /home/smuks/OpenCode/pike-lsp/pike-scripts

# Test basic get/put/clear
pike -e '
LSP.Cache.put("program_cache", "key1", 42);
write("Get: %d\n", LSP.Cache.get("program_cache", "key1"));
LSP.Cache.clear("program_cache");
write("After clear: %d\n", LSP.Cache.get("program_cache", "key1"));
'

# Test LRU eviction
pike -e '
LSP.Cache.set_limits(3, 3);  // Set small limit
for (int i = 0; i < 5; i++) {
    LSP.Cache.put("program_cache", "key" + (string)i, i);
}
mapping stats = LSP.Cache.get_stats();
write("Size: %d/%d\n", stats->program_size, stats->program_max);
'

# Test statistics
pike -e '
LSP.Cache.put("stdlib_cache", "test", ([]));
LSP.Cache.get("stdlib_cache", "test");
LSP.Cache.get("stdlib_cache", "missing");
mapping stats = LSP.Cache.get_stats();
write("Hits: %d, Misses: %d\n", stats->stdlib_hits, stats->stdlib_misses);
'
```

Expected results:
- Basic test outputs: Get: 42, After clear: 0
- LRU test shows size limited to 3 despite inserting 5 items
- Statistics show correct hit/miss counts
</verification>

<success_criteria>
1. LSP.pmod/Cache.pmod file exists at /home/smuks/OpenCode/pike-lsp/pike-scripts/LSP.pmod/Cache.pmod
2. Pike interpreter can load the module without errors
3. get() retrieves values that were put() in cache
4. put() triggers LRU eviction when size limit is exceeded
5. clear() empties the specified cache
6. get_stats() returns accurate hit/miss counts and sizes
7. Both program_cache and stdlib_cache work correctly
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
