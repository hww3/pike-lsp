---
phase: 01-foundation
plan: 04
type: tdd
wave: 2
depends_on: [01-01, 01-02, 01-03]
files_modified:
  - LSP.pmod/Compat.pmod
  - LSP.pmod/Cache.pmod
  - test/tests/foundation-tests.pike
autonomous: true

must_haves:
  truths:
    - "Compat.pmod unit tests verify feature detection on current Pike version"
    - "Compat.trim_whites() polyfill produces same output as native String.trim_whites()"
    - "Cache.pmod unit tests verify LRU eviction behavior"
    - "Cache statistics accurately track hits, misses, and evictions"
    - "All tests pass with `pike test/tests/foundation-tests.pike`"
  artifacts:
    - path: "test/tests/foundation-tests.pike"
      provides: "Unit tests for Compat.pmod and Cache.pmod"
      min_lines: 100
      contains: "test_compat_pike_version", "test_compat_trim_whites", "test_cache_lru"
  key_links:
    - from: "foundation-tests.pike"
      to: "LSP.pmod"
      via: "module import"
      pattern: "#include <LSP.pmod>"
---

<objective>
Write comprehensive unit tests for Compat.pmod feature detection and Cache.pmod LRU operations, ensuring the foundation modules work correctly across Pike versions.

Purpose: Unit tests verify that Compat.pmod correctly detects Pike version and that the trim_whites polyfill produces identical output to native String.trim_whites(). They also verify Cache.pmod LRU eviction behavior, statistics tracking, and edge cases. These tests guard against regressions as the codebase evolves and serve as documentation of expected behavior.

Output: test/tests/foundation-tests.pike with passing tests for Compat.pmod (version detection, trim_whites polyfill) and Cache.pmod (get/put/clear, LRU eviction, statistics).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/codebase/TESTING.md
</context>

<tasks>

<task type="auto">
  <name>Create test file structure and test runner</name>
  <files>test/tests/foundation-tests.pike</files>
  <action>
    Create the test infrastructure at /home/smuks/OpenCode/pike-lsp/test/tests/foundation-tests.pike:

    1. Create test directory if it doesn't exist:
       ```
       test/tests/
       ```

    2. Create a simple test runner framework with:
       - Test discovery (functions named `test_*`)
       - Pass/fail counting
       - Error reporting with test name
       - Summary output

    Test runner structure:
    ```pike
    #!/usr/bin/env pike

    int tests_run = 0;
    int tests_passed = 0;
    int tests_failed = 0;
    array(string) failures = ({});

    void run_test(function test_func, string name) {
        tests_run++;
        mixed err = catch {
            test_func();
            tests_passed++;
            write("  PASS: %s\n", name);
        };
        if (err) {
            tests_failed++;
            failures += ({ name });
            write("  FAIL: %s\n", name);
            write("    Error: %s\n", describe_error(err));
        }
    }

    void main() {
        write("LSP Foundation Tests\n");
        write("=====================\n\n");

        // Run all test functions
        // Tests will be added in subsequent tasks

        write("\n");
        write("Results: %d run, %d passed, %d failed\n", tests_run, tests_passed, tests_failed);

        if (tests_failed > 0) {
            write("\nFailed tests:\n");
            foreach (failures, string name) {
                write("  - %s\n", name);
            }
            exit(1);
        }
        exit(0);
    }
    ```
  </action>
  <verify>chmod +x test/tests/foundation-tests.pike && pike test/tests/foundation-tests.pike 2>&1</verify>
  <done>Test runner executes and reports 0 tests (placeholder ready for tests)</done>
</task>

<task type="auto">
  <name>Write Compat.pmod unit tests</name>
  <files>test/tests/foundation-tests.pike</files>
  <action>
    Add unit tests for Compat.pmod to foundation-tests.pike:

    1. **test_compat_pike_version** (FND-12):
       ```pike
    void test_compat_pike_version() {
        array version = LSP.Compat.pike_version();
        if (sizeof(version) < 3) {
            error("Version array too small: %O\n", version);
        }
        if (version[0] < 7) {
            error("Pike version too old: %O\n", version);
        }
        // Verify version is 7.6, 7.8, or 8.x
        if (!(version[0] == 7 && (version[1] == 6 || version[1] == 8)) &&
            version[0] != 8) {
            error("Unsupported Pike version: %O\n", version);
        }
    }
       ```

    2. **test_compat_pi_version_constant**:
       ```pike
    void test_compat_pi_version_constant() {
        string version_str = LSP.Compat.PIKE_VERSION_STRING;
        if (!stringp(version_str) || sizeof(version_str) == 0) {
            error("PIKE_VERSION_STRING invalid: %O\n", version_str);
        }
        // Verify it matches format "X.Y.Z"
        if (!Regexp.Pimple.Simple("^[0-9]+\\.[0-9]+\\.[0-9]+")->match(version_str)) {
            error("PIKE_VERSION_STRING format invalid: %s\n", version_str);
        }
    }
       ```

    3. **test_compat_trim_whites_basic**:
       ```pike
    void test_compat_trim_whites_basic() {
        // Test leading whitespace
        string result1 = LSP.Compat.trim_whites("  test");
        if (result1 != "test") {
            error("Leading whitespace not trimmed: %O\n", result1);
        }

        // Test trailing whitespace
        string result2 = LSP.Compat.trim_whites("test  ");
        if (result2 != "test") {
            error("Trailing whitespace not trimmed: %O\n", result2);
        }

        // Test both
        string result3 = LSP.Compat.trim_whites("  test  ");
        if (result3 != "test") {
            error("Both sides not trimmed: %O\n", result3);
        }
    }
       ```

    4. **test_compat_trim_whites_tabs_and_newlines**:
       ```pike
    void test_compat_trim_whites_tabs_and_newlines() {
        // Test tabs
        string result1 = LSP.Compat.trim_whites("\ttest\t");
        if (result1 != "test") {
            error("Tabs not trimmed: %O\n", result1);
        }

        // Test newlines
        string result2 = LSP.Compat.trim_whites("\ntest\n");
        if (result2 != "test") {
            error("Newlines not trimmed: %O\n", result2);
        }

        // Test mixed whitespace
        string result3 = LSP.Compat.trim_whites(" \n\t test \t\n ");
        if (result3 != "test") {
            error("Mixed whitespace not trimmed: %O\n", result3);
        }
    }
       ```

    5. **test_compat_trim_whites_empty**:
       ```pike
    void test_compat_trim_whites_empty() {
        // Test empty string
        string result1 = LSP.Compat.trim_whites("");
        if (result1 != "") {
            error("Empty string modified: %O\n", result1);
        }

        // Test whitespace only
        string result2 = LSP.Compat.trim_whites("   ");
        if (result2 != "") {
            error("Whitespace-only not trimmed to empty: %O\n", result2);
        }
    }
       ```

    6. **test_compat_trim_whites_preserves_internal**:
       ```pike
    void test_compat_trim_whites_preserves_internal() {
        // Test that internal whitespace is preserved
        string result = LSP.Compat.trim_whites("  hello  world  ");
        if (result != "hello  world") {
            error("Internal whitespace modified: %O\n", result);
        }
    }
       ```

    Register these tests in main():
    ```pike
    run_test(test_compat_pike_version, "Compat.pike_version");
    run_test(test_compat_pi_version_constant, "Compat.PIKE_VERSION_STRING");
    run_test(test_compat_trim_whites_basic, "Compat.trim_whites basic");
    run_test(test_compat_trim_whites_tabs_and_newlines, "Compat.trim_whites tabs/newlines");
    run_test(test_compat_trim_whites_empty, "Compat.trim_whites empty strings");
    run_test(test_compat_trim_whites_preserves_internal, "Compat.trim_whites internal whitespace");
    ```

    These tests verify FND-12 requirement: "Unit tests for Compat.pmod feature detection".
  </action>
  <verify>pike test/tests/foundation-tests.pike 2>&1 | grep -E "(PASS|FAIL|Results)"</verify>
  <done>All 6 Compat.pmod tests pass</done>
</task>

<task type="auto">
  <name>Write Cache.pmod unit tests</name>
  <files>test/tests/foundation-tests.pike</files>
  <action>
    Add unit tests for Cache.pmod to foundation-tests.pike:

    1. **test_cache_program_put_get** (FND-13):
       ```pike
    void test_cache_program_put_get() {
        // Clear cache first
        LSP.Cache.clear("program_cache");

        // Put and get
        LSP.Cache.put("program_cache", "key1", "program1");
        mixed result = LSP.Cache.get("program_cache", "key1");
        if (result != "program1") {
            error("Put/get failed: expected 'program1', got %O\n", result);
        }

        // Get non-existent key
        mixed missing = LSP.Cache.get("program_cache", "nonexistent");
        if (missing != 0) {
            error("Missing key should return 0, got %O\n", missing);
        }
    }
       ```

    2. **test_cache_stdlib_put_get**:
       ```pike
    void test_cache_stdlib_put_get() {
        LSP.Cache.clear("stdlib_cache");

        // Put and get
        mapping data = (["symbols": (["foo": "bar"])]);
        LSP.Cache.put("stdlib_cache", "module1", data);
        mixed result = LSP.Cache.get("stdlib_cache", "module1");
        if (result->symbols->foo != "bar") {
            error("Stdlib put/get failed: %O\n", result);
        }
    }
       ```

    3. **test_cache_clear**:
       ```pike
    void test_cache_clear() {
        LSP.Cache.clear("program_cache");

        LSP.Cache.put("program_cache", "key1", "value1");
        LSP.Cache.put("program_cache", "key2", "value2");

        LSP.Cache.clear("program_cache");

        mixed result1 = LSP.Cache.get("program_cache", "key1");
        mixed result2 = LSP.Cache.get("program_cache", "key2");

        if (result1 != 0 || result2 != 0) {
            error("Clear failed: keys still exist\n");
        }
    }
       ```

    4. **test_cache_program_lru_eviction**:
       ```pike
    void test_cache_program_lru_eviction() {
        LSP.Cache.clear("program_cache");
        LSP.Cache.set_limits(3, 50);  // Set small limit

        // Fill cache to limit
        LSP.Cache.put("program_cache", "key1", "value1");
        LSP.Cache.put("program_cache", "key2", "value2");
        LSP.Cache.put("program_cache", "key3", "value3");

        // Access key1 to make it recently used
        LSP.Cache.get("program_cache", "key1");

        // Add one more - should evict key2 (least recently used)
        LSP.Cache.put("program_cache", "key4", "value4");

        // key2 should be evicted, key1 and key3 should remain
        if (LSP.Cache.get("program_cache", "key2") != 0) {
            error("LRU eviction failed: key2 should have been evicted\n");
        }
        if (LSP.Cache.get("program_cache", "key1") != "value1") {
            error("LRU eviction error: key1 should remain\n");
        }
        if (LSP.Cache.get("program_cache", "key3") != "value3") {
            error("LRU eviction error: key3 should remain\n");
        }
        if (LSP.Cache.get("program_cache", "key4") != "value4") {
            error("LRU eviction error: key4 should exist\n");
        }
    }
       ```

    5. **test_cache_statistics**:
       ```pike
    void test_cache_statistics() {
        LSP.Cache.clear("program_cache");
        LSP.Cache.clear("stdlib_cache");

        // Initial stats
        mapping stats = LSP.Cache.get_stats();
        if (stats->program_size != 0) {
            error("Initial program_size should be 0\n");
        }

        // Add items
        LSP.Cache.put("program_cache", "key1", "value1");
        LSP.Cache.put("program_cache", "key2", "value2");

        // Hit and miss
        LSP.Cache.get("program_cache", "key1");  // hit
        LSP.Cache.get("program_cache", "missing");  // miss

        stats = LSP.Cache.get_stats();
        if (stats->program_size != 2) {
            error("Size should be 2, got %d\n", stats->program_size);
        }
        if (stats->program_hits < 1) {
            error("Hits should be at least 1, got %d\n", stats->program_hits);
        }
        if (stats->program_misses < 1) {
            error("Misses should be at least 1, got %d\n", stats->program_misses);
        }
    }
       ```

    6. **test_cache_set_limits**:
       ```pike
    void test_cache_set_limits() {
        LSP.Cache.set_limits(5, 10);

        mapping stats = LSP.Cache.get_stats();
        if (stats->program_max != 5) {
            error("program_max should be 5, got %d\n", stats->program_max);
        }
        if (stats->stdlib_max != 10) {
            error("stdlib_max should be 10, got %d\n", stats->stdlib_max);
        }
    }
       ```

    7. **test_cache_clear_all**:
       ```pike
    void test_cache_clear_all() {
        LSP.Cache.put("program_cache", "key1", "value1");
        LSP.Cache.put("stdlib_cache", "module1", (["data": "test"]));

        LSP.Cache.clear("all");

        mapping stats = LSP.Cache.get_stats();
        if (stats->program_size != 0 || stats->stdlib_size != 0) {
            error("Clear all failed: sizes not zero\n");
        }
    }
       ```

    Register these tests in main():
    ```pike
    run_test(test_cache_program_put_get, "Cache program put/get");
    run_test(test_cache_stdlib_put_get, "Cache stdlib put/get");
    run_test(test_cache_clear, "Cache clear");
    run_test(test_cache_program_lru_eviction, "Cache LRU eviction");
    run_test(test_cache_statistics, "Cache statistics");
    run_test(test_cache_set_limits, "Cache set_limits");
    run_test(test_cache_clear_all, "Cache clear all");
    ```

    These tests verify FND-13 requirement: "Unit tests for Cache.pmod LRU operations".
  </action>
  <verify>pike test/tests/foundation-tests.pike 2>&1 | grep -E "(PASS|FAIL|Results)"</verify>
  <done>All 7 Cache.pmod tests pass</done>
</task>

<task type="auto">
  <name>Verify all tests pass and create executable</name>
  <files>test/tests/foundation-tests.pike</files>
  <action>
    1. Make the test file executable:
       ```bash
       chmod +x /home/smuks/OpenCode/pike-lsp/test/tests/foundation-tests.pike
       ```

    2. Run all tests and verify complete pass:
       ```bash
       cd /home/smuks/OpenCode/pike-lsp
       pike test/tests/foundation-tests.pike
       ```

    3. Verify the output shows:
       - 13 tests run (6 Compat + 7 Cache)
       - 13 passed
       - 0 failed
       - Exit code 0

    4. If any tests fail, debug and fix before considering this task complete.

    The test file should include a shebang and be executable as a standalone script.
  </action>
  <verify>pike test/tests/foundation-tests.pike && echo "Exit code: $?"</verify>
  <done>
    - All 13 tests pass (6 Compat, 7 Cache)
    - Exit code is 0
    - Test output shows proper pass/fail reporting
  </done>
</task>

</tasks>

<verification>
After completing all tasks, run the full test suite:

```bash
cd /home/smuks/OpenCode/pike-lsp
pike test/tests/foundation-tests.pike
```

Expected output:
```
LSP Foundation Tests
=====================

  PASS: Compat.pike_version
  PASS: Compat.PIKE_VERSION_STRING
  PASS: Compat.trim_whites basic
  PASS: Compat.trim_whiles tabs/newlines
  PASS: Compat.trim_whites empty strings
  PASS: Compat.trim_whites internal whitespace
  PASS: Cache program put/get
  PASS: Cache stdlib put/get
  PASS: Cache clear
  PASS: Cache LRU eviction
  PASS: Cache statistics
  PASS: Cache set_limits
  PASS: Cache clear all

Results: 13 run, 13 passed, 0 failed
```

Exit code should be 0.
</verification>

<success_criteria>
1. test/tests/foundation-tests.pike exists and is executable
2. All 13 tests pass (6 Compat tests, 7 Cache tests)
3. Test output clearly indicates which tests passed/failed
4. Exit code is 0 on success, 1 on failure
5. Tests can be run standalone without external dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-04-SUMMARY.md`
</output>
