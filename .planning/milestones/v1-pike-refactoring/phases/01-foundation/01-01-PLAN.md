---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - LSP.pmod/module.pmod
autonomous: true

must_haves:
  truths:
    - "LSP.pmod directory exists and is loadable by Pike interpreter"
    - "LSP.MAX_TOP_LEVEL_ITERATIONS constant can be imported"
    - "LSP.LSPError class can be instantiated"
    - "LSP.json_decode and LSP.json_encode functions exist"
    - "LSP.debug_mode can be set and retrieved"
    - "LSP.debug() function only outputs when debug_mode is enabled"
  artifacts:
    - path: "LSP.pmod/module.pmod"
      provides: "Main module entry point with constants, error class, JSON helpers, debug logging"
      min_lines: 50
      exports: ["MAX_TOP_LEVEL_ITERATIONS", "MAX_BLOCK_ITERATIONS", "LSPError", "json_decode", "json_encode", "debug_mode", "debug"]
  key_links:
    - from: "module.pmod"
      to: "Pike interpreter"
      via: "module load mechanism"
      pattern: "pike -e 'mixed x = LSP.module;'"
---

<objective>
Create LSP.pmod directory structure with module.pmod containing shared constants, error classes, JSON helper functions, and debug logging infrastructure.

Purpose: module.pmod serves as the main entry point for the LSP module, providing foundational utilities that all other components will import. This establishes the shared infrastructure that prevents code duplication across handler modules.

Output: Loadable LSP.pmod/module.pmod with constants (MAX_TOP_LEVEL_ITERATIONS, MAX_BLOCK_ITERATIONS), LSPError base class, JSON helpers (json_decode, json_encode), and debug logging (debug_mode flag, debug() function).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/codebase/CONVENTIONS.md
@pike-scripts/analyzer.pike
</context>

<tasks>

<task type="auto">
  <name>Create LSP.pmod directory structure</name>
  <files>LSP.pmod</files>
  <action>
    Create the LSP.pmod directory at the root of the pike-scripts directory (where analyzer.pike lives).

    IMPORTANT: The directory must be named `LSP.pmod` - this is Pike's module naming convention.

    Location: /home/smuks/OpenCode/pike-lsp/pike-scripts/LSP.pmod/

    Do NOT create any files yet - just the directory structure.
  </action>
  <verify>ls -la /home/smuks/OpenCode/pike-lsp/pike-scripts/LSP.pmod/</verify>
  <done>LSP.pmod directory exists</done>
</task>

<task type="auto">
  <name>Create module.pmod with constants and shared utilities</name>
  <files>LSP.pmod/module.pmod</files>
  <action>
    Create LSP.pmod/module.pmod with the following components:

    1. **Constants** (extracted from analyzer.pike lines 26-27):
       - `constant MAX_TOP_LEVEL_ITERATIONS = 10000;`
       - `constant MAX_BLOCK_ITERATIONS = 500;`

    2. **LSPError base class** (FND-03):
       ```pike
       class LSPError(mixed code, string message) {
           constant error_code = code;
           constant error_message = message;
       }
       ```

    3. **JSON helper functions** (FND-04):
       ```pike
       mixed json_decode(string data) {
           return Standards.JSON.decode(data);
       }

       string json_encode(mixed data, void|int flags) {
           return Standards.JSON.encode(data, flags);
       }
       ```

    4. **Debug logging infrastructure** (FND-11, extracted from analyzer.pike lines 37-44):
       ```pike
       int debug_mode = 0;

       void debug(string fmt, mixed... args) {
           if (debug_mode) {
               werror(fmt, @args);
           }
       }
       ```

    Follow Pike conventions:
    - Use `//!` for documentation comments
    - Use `constant` for compile-time constants
    - Use `protected` for internal functions (none needed for this simple case)

    Reference the existing patterns in analyzer.pike for the exact implementation of these utilities.
  </action>
  <verify>pike -e 'write("%s\n", LSP.MAX_TOP_LEVEL_ITERATIONS);' 2>&1 | grep -q "10000"</verify>
  <done>
    - LSP.MAX_TOP_LEVEL_ITERATIONS equals 10000
    - LSP.MAX_BLOCK_ITERATIONS equals 500
    - LSP.LSPError class can be instantiated
    - LSP.json_decode and json_encode functions work
    - LSP.debug_mode defaults to 0
    - LSP.debug() only outputs when debug_mode is 1
  </done>
</task>

</tasks>

<verification>
After completing all tasks, verify the module loads correctly:

```bash
cd /home/smuks/OpenCode/pike-lsp/pike-scripts
pike -e 'write("MAX_TOP_LEVEL_ITERATIONS=%d\n", LSP.MAX_TOP_LEVEL_ITERATIONS);'
pike -e 'LSP.debug("test output\n");'
pike -e 'LSP.debug_mode = 1; LSP.debug("test output\n");'
pike -e 'mixed err = LSP.LSPError(-32600, "test"); write("%s\n", err->error_message);'
```

Expected results:
- First command outputs: MAX_TOP_LEVEL_ITERATIONS=10000
- Second command produces no output
- Third command outputs: test output
- Fourth command outputs: test
</verification>

<success_criteria>
1. LSP.pmod/module.pmod file exists at /home/smuks/OpenCode/pike-lsp/pike-scripts/LSP.pmod/module.pmod
2. Pike interpreter can load the module without errors
3. All constants are accessible (MAX_TOP_LEVEL_ITERATIONS, MAX_BLOCK_ITERATIONS)
4. LSPError class can be instantiated
5. JSON helpers work correctly
6. Debug logging respects the debug_mode flag
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
