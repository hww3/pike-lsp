//! Completions.pike - Code completion context analysis
//!
//! This file provides completion context analysis for Pike code.
//! It analyzes code around the cursor position to determine:
//! - What kind of completion is needed (global, identifier, member access, scope access)
//! - The object/module being accessed (for member/scope access)
//! - The prefix to complete
//!
//! Design pattern:
//! - create(object ctx) constructor for context injection
//! - Handlers wrap errors in catch blocks
//! - Uses Parser.Pike for tokenization

//! Private context field (reserved for future use with LSP context)
protected object context;

//! Get access to module.pmod helpers
//! In a .pmod subdirectory, we access module.pmod functions via module program
protected program module_program = master()->resolv("LSP.Analysis.module");

//! Create a new Completions instance
//! @param ctx Optional LSP context object
void create(object ctx) {
    context = ctx;
}

//! Get completion context at a specific position using tokenization
//!
//! Analyzes code around cursor position to determine completion context.
//! This enables accurate code completion in LSP clients.
mapping handle_get_completion_context(mapping params) {
    string code = params->code || "";
    int target_line = params->line || 1;
    int target_char = params->character || 0;

    mapping result = ([
        "context": "none",
        "objectName": "",
        "prefix": "",
        "operator": ""
    ]);

    array(string) split_tokens = ({});
    array(object) pike_tokens = ({});

    mixed err = catch {
        split_tokens = Parser.Pike.split(code);
        pike_tokens = Parser.Pike.tokenize(split_tokens);

        // Find tokens around cursor position
        // We need to find token at or just before cursor
        int token_idx = -1;

        for (int i = 0; i < sizeof(pike_tokens); i++) {
            object tok = pike_tokens[i];
            int tok_line = tok->line;
            // Use token's native character position from tokenizer
            // Note: Parser.Pike.tokenize() doesn't provide character positions, so this is 0
            int tok_char = tok->character || 0;

            // Check if this token is at or before our cursor
            if (tok_line < target_line ||
                (tok_line == target_line && tok_char <= target_char)) {
                token_idx = i;
            } else {
                break;
            }
        }

        // Check if we only have whitespace tokens (empty or whitespace-only file)
        bool has_non_ws_tokens = false;
        for (int i = 0; i < sizeof(pike_tokens); i++) {
            string text = LSP.Compat.trim_whites(pike_tokens[i]->text);
            if (sizeof(text) > 0) {
                has_non_ws_tokens = true;
                break;
            }
        }

        if (!has_non_ws_tokens) {
            // Only whitespace - treat as global context
            result->context = "global";
            return ([
                "result": result,
                "splitTokens": split_tokens,
            ]);
        }

        // Extract prefix by looking at actual text at cursor position
        string prefix = extract_prefix_at_cursor(code, target_line, target_char);
        result->prefix = prefix;

        // NEW: Check if cursor is immediately after a dot operator (with optional whitespace)
        // This handles "Module.|" pattern where there's no partial identifier after the dot
        bool cursor_after_dot = is_cursor_after_dot(code, target_line, target_char);

        // Scan backwards to find most recent access operator
        string found_operator = "";
        int operator_idx = -1;

        for (int i = token_idx; i >= 0; i--) {
            object tok = pike_tokens[i];
            string text = LSP.Compat.trim_whites(tok->text);

            // Check if this is an access operator
            if (text == "->" || text == "." || text == "::") {
                found_operator = text;
                operator_idx = i;
                break;
            }

            // Stop at statement boundaries
            if (text == ";" || text == "{" || text == "}") {
                break;
            }
        }

        if (found_operator != "") {
            // Found an access operator - this is member/scope access
            result->operator = found_operator;

            // Build typeChain: track all identifiers in chain (obj->getFile()->close())
            // Scan backwards from cursor to collect all -> operators and their targets
            array(string) type_chain = ({});
            int chain_idx = token_idx;
            while (chain_idx >= 0) {
                object tok = pike_tokens[chain_idx];
                string text = LSP.Compat.trim_whites(tok->text);

                // Stop at statement boundaries
                if (text == ";" || text == "{" || text == "}" ||
                    text == "(" || text == ")" || text == ",") {
                    break;
                }

                // If we find an arrow operator, identifier before it is part of chain
                if (text == "->") {
                    // Look backward for identifier before this ->
                    for (int j = chain_idx - 1; j >= 0; j--) {
                        object prev_tok = pike_tokens[j];
                        string prev_text = LSP.Compat.trim_whites(prev_tok->text);

                        // Stop at boundaries or other operators
                        if (sizeof(prev_text) == 0 ||
                            prev_text == ";" || prev_text == "{" || prev_text == "}" ||
                            prev_text == "(" || prev_text == ")" || prev_text == "," ||
                            prev_text == "=" || prev_text == "==" || prev_text == "+" ||
                            prev_text == "-" || prev_text == "*" || prev_text == "/" ||
                            prev_text == "->" || prev_text == "::" || prev_text == ".") {
                            break;
                        }

                        // Found an identifier - add to chain (reverse order since we scan backward)
                        if (sizeof(prev_text) > 0) {
                            type_chain = ({prev_text}) + type_chain;
                            break;
                        }
                    }
                    // Continue scanning backward from before this identifier
                    chain_idx = j - 1;
                } else {
                    chain_idx--;
                }
            }

            // Find object/module name by looking backwards from operator
            string object_parts = "";
            for (int i = operator_idx - 1; i >= 0; i--) {
                object obj_tok = pike_tokens[i];
                string obj_text = LSP.Compat.trim_whites(obj_tok->text);

                // Stop at statement boundaries or other operators
                if (sizeof(obj_text) == 0 ||
                    obj_text == ";" || obj_text == "{" || obj_text == "}" ||
                    obj_text == "(" || obj_text == ")" || obj_text == "," ||
                    obj_text == "=" || obj_text == "==" || obj_text == "+" ||
                    obj_text == "-" || obj_text == "*" || obj_text == "/" ||
                    obj_text == "->" || obj_text == "::" || obj_text == ".") {
                    break;
                }

                // Build object name (handling dots in qualified names)
                if (sizeof(object_parts) > 0) {
                    object_parts = obj_text + object_parts;
                } else {
                    object_parts = obj_text;
                }
            }

            result->objectName = object_parts;
            result->typeChain = type_chain;

            if (found_operator == "::") {
                result->context = "scope_access";
            } else {
                result->context = "member_access";
            }
        } else if (cursor_after_dot) {
            // Cursor is after a dot - scan backwards to find identifier before it
            // This handles "Array.|" (no token after dot) and "Array.f|"
            array lines = code / "\\n";
            if (target_line > 0 && target_line <= sizeof(lines)) {
                string line = lines[target_line - 1];

                // Look backwards from cursor position, skipping whitespace
                int i = target_char - 2;  // Start before dot
                while (i >= 0 && (line[i] == ' ' || line[i] == '\\t')) {
                    i--;
                }

                // Extract identifier by collecting identifier characters
                string identifier_before_dot = "";
                while (i >= 0) {
                    int ch = line[i];
                    if ((ch >= 'A' && ch <= 'Z') ||
                        (ch >= 'a' && ch <= 'z') ||
                        ch == '_') {
                        // Prepend to build identifier (scanning backwards)
                        identifier_before_dot = sprintf("%s%s", ch, identifier_before_dot);
                        i--;
                    } else {
                        break;
                    }
                }

                if (sizeof(identifier_before_dot) > 0) {
                    result->context = "member_access";
                    result->operator = ".";
                    result->objectName = identifier_before_dot;
                }
            }
        } else {
            // No access operator found - regular identifier completion
            result->context = "identifier";
        }
    };

    if (err) {
        // Gracefully degrade - return default "none" context on error
        // Log for debugging but don't crash
        werror("get_completion_context error: %s\\n", describe_error(err));
    }

    return ([
        "result": result,
        // PERF-003: Include splitTokens for caching (tokens are not JSON-serializable)
        "splitTokens": split_tokens,
    ]);
}

//! PERF-003: Get completion context using pre-tokenized input
//!
//! Optimized version that skips tokenization when the caller provides
//! cached tokens from a previous request. This provides ~10x speedup
//! for repeated completion requests on unchanged documents.
//!
//! @param params Mapping with "code", "line", "character", and "splitTokens"
//! @returns Mapping with "result" containing completion context
mapping handle_get_completion_context_cached(mapping params) {
    string code = params->code || "";
    int target_line = params->line || 1;
    int target_char = params->character || 0;
    array(string) split_tokens = params->splitTokens || ({});

    mapping result = ([
        "context": "none",
        "objectName": "",
        "prefix": "",
        "operator": ""
    ]);

    mixed err = catch {
        // Find tokens around cursor position
        int token_idx = -1;

        for (int i = 0; i < sizeof(split_tokens); i++) {
            object tok = split_tokens[i];
            int tok_line = tok->line;
            // Use token's native character position from tokenizer
            int tok_char = tok->character || 0;

            // Check if this token is at or before our cursor
            if (tok_line < target_line ||
                (tok_line == target_line && tok_char <= target_char)) {
                token_idx = i;
            } else {
                break;
            }
        }

        if (token_idx == -1) {
            result->context = "global";
            return (["result": result]);
        }

        // Check if we only have whitespace tokens (empty or whitespace-only file)
        bool has_non_ws_tokens = false;
        for (int i = 0; i < sizeof(split_tokens); i++) {
            string text = LSP.Compat.trim_whites(split_tokens[i]->text);
            if (sizeof(text) > 0) {
                has_non_ws_tokens = true;
                break;
            }
        }

        if (!has_non_ws_tokens) {
            // Only whitespace - treat as global context
            result->context = "global";
            return (["result": result]);
        }

        // Extract prefix by looking at actual text at cursor position
        string prefix = extract_prefix_at_cursor(code, target_line, target_char);
        result->prefix = prefix;

        // NEW: Check if cursor is immediately after a dot operator (with optional whitespace)
        bool cursor_after_dot = is_cursor_after_dot(code, target_line, target_char);

        // Scan backwards to find most recent access operator
        string found_operator = "";
        int operator_idx = -1;

        for (int i = token_idx; i >= 0; i--) {
            object tok = split_tokens[i];
            string text = LSP.Compat.trim_whites(tok->text);

            // Check if this is an access operator
            if (text == "->" || text == "." || text == "::") {
                found_operator = text;
                operator_idx = i;
                break;
            }

            // Stop at statement boundaries
            if (text == ";" || text == "{" || text == "}") {
                break;
            }
        }

        if (found_operator != "") {
            // Found an access operator - this is member/scope access
            result->operator = found_operator;

            // Build typeChain: track all identifiers in chain (obj->getFile()->close())
            // Scan backwards from cursor to collect all -> operators and their targets
            array(string) type_chain = ({});
            int chain_idx = token_idx;
            while (chain_idx >= 0) {
                object tok = split_tokens[chain_idx];
                string text = LSP.Compat.trim_whites(tok->text);

                // Stop at statement boundaries
                if (text == ";" || text == "{" || text == "}" ||
                    text == "(" || text == ")" || text == ",") {
                    break;
                }

                // If we find an arrow operator, identifier before it is part of chain
                if (text == "->") {
                    // Look backward for identifier before this ->
                    for (int j = chain_idx - 1; j >= 0; j--) {
                        object prev_tok = split_tokens[j];
                        string prev_text = LSP.Compat.trim_whites(prev_tok->text);

                        // Stop at boundaries or other operators
                        if (sizeof(prev_text) == 0 ||
                            prev_text == ";" || prev_text == "{" || prev_text == "}" ||
                            prev_text == "(" || prev_text == ")" || prev_text == "," ||
                            prev_text == "=" || prev_text == "==" || prev_text == "+" ||
                            prev_text == "-" || prev_text == "*" || prev_text == "/" ||
                            prev_text == "->" || prev_text == "::" || prev_text == ".") {
                            break;
                        }

                        // Found an identifier - add to chain (reverse order since we scan backward)
                        if (sizeof(prev_text) > 0) {
                            type_chain = ({prev_text}) + type_chain;
                            break;
                        }
                    }
                    // Continue scanning backward from before this identifier
                    chain_idx = j - 1;
                } else {
                    chain_idx--;
                }
            }

            // Find object/module name by looking backwards from operator
            string object_parts = "";
            for (int i = operator_idx - 1; i >= 0; i--) {
                object obj_tok = split_tokens[i];
                string obj_text = LSP.Compat.trim_whites(obj_tok->text);

                // Stop at statement boundaries or other operators
                if (sizeof(obj_text) == 0 ||
                    obj_text == ";" || obj_text == "{" || obj_text == "}" ||
                    obj_text == "(" || obj_text == ")" || obj_text == "," ||
                    obj_text == "=" || obj_text == "==" || obj_text == "+" ||
                    obj_text == "-" || obj_text == "*" || obj_text == "/" ||
                    obj_text == "->" || obj_text == "::" || obj_text == ".") {
                    break;
                }

                // Build object name (handling dots in qualified names)
                if (sizeof(object_parts) > 0) {
                    object_parts = obj_text + object_parts;
                } else {
                    object_parts = obj_text;
                }
            }

            result->objectName = object_parts;
            result->typeChain = type_chain;

            if (found_operator == "::") {
                result->context = "scope_access";
            } else {
                result->context = "member_access";
            }
        } else if (cursor_after_dot) {
            // Cursor is after a dot - scan backwards to find identifier before it
            // This handles "Array.|" (no token after dot) and "Array.f|"
            array lines = code / "\\n";
            if (target_line > 0 && target_line <= sizeof(lines)) {
                string line = lines[target_line - 1];

                // Look backwards from cursor position, skipping whitespace
                int i = target_char - 2;  // Start before dot
                while (i >= 0 && (line[i] == ' ' || line[i] == '\\t')) {
                    i--;
                }

                // Extract identifier by collecting identifier characters
                string identifier_before_dot = "";
                while (i >= 0) {
                    int ch = line[i];
                    if ((ch >= 'A' && ch <= 'Z') ||
                        (ch >= 'a' && ch <= 'z') ||
                        ch == '_') {
                        // Prepend to build identifier (scanning backwards)
                        identifier_before_dot = sprintf("%s%s", ch, identifier_before_dot);
                        i--;
                    } else {
                        break;
                    }
                }

                if (sizeof(identifier_before_dot) > 0) {
                    result->context = "member_access";
                    result->operator = ".";
                    result->objectName = identifier_before_dot;
                }
            }
        } else {
            // No access operator found - regular identifier completion
            result->context = "identifier";
        }
    };

    if (err) {
        // Gracefully degrade - return default "none" context on error
        werror("get_completion_context_cached error: %s\\n", describe_error(err));
    }

    return ([
        "result": result
    ]);
}
